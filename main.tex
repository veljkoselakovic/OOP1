\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english,serbian]{babel}
\usepackage[fleqn]{mathtools}
\usepackage[table,xcdraw]{xcolor}
\usepackage{marginnote}
\usepackage{tikz}
\usepackage{relsize}
\usepackage{enumitem}
\usepackage{wasysym}
\usepackage{multicol}
\usepackage{listings}
\usepackage{color}
\usepackage[none]{hyphenat}
\usepackage[bottom = 0.5in]{geometry}
\usepackage{changepage}
\usepackage{centernot}
\usepackage{tikz-uml}
\usepackage{multirow}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Struktura dokumenta             %
% Sekcije = Pojedinačna prezentacija            %
% Ime stavke = Ime slajda                       %
% Tekst = Tekst sa slajdova/Moje tumačenje      %
% Kod = Primeri sa slajdova/Moji primeri        %
%                   Komande                     %
% \section - za novu sekciju                    %
% \begin{xitemize} - Okruženje za ime stavke    %
%               Pojedinačna stavka sa \item     %
% \begin{itemize} - Okruženje za tekst          %
%               Pojedinačna stavka sa \item     %
% \begin{enumerate} - Okruženje za tekst označen%
%               brojevima. Pojedinačna stavka   %
%               sa \item                        %
% \begin{lstlisting} - Okruženje za kod         %
% \begin{multicols}{2} - Okruženje za dve       %
%               kolone. Koristi se ako je kod   %
%               kratak ili je sam tekst         %
%               struktuiran da ima dosta mesta  %
%               dosta mesta sa desne strane     %
% \columnbreak - Komanda koja odvaja dve kolone %
% \inlinecode{ TEKST } - Koristi specijalan font%
%               da označi reč kao kod. Koristi  %
%               se kad je kratak kod do jednog  %
%               reda, ili ako je keyword u textu%
% \checkmark - Znak za štikliranje              %
% \boxedimportant[ ANOTACIJA ]{ TEKST } - Tekst %
%               za koji se smatra da treba da   %
%               bude uokviren. Anotacija nije   %
%               obavezna, ali može da bliže     %
%               objasni zašto je uokvireno      %
% \hzline - Horizontalna linija za odvajanje    %
%               gradiva u zavisnosti od smera   %
%               i/ili kolokvijuma               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Definisanje lstset za formatiran kod
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% Definisanje okoline za naslove sa vecim znacenjem - jako debilno
\newenvironment{xitemize}{%
    
    \itemize
    \larger
}{%
    \enditemize
}
\let\olditemize\itemize
\let\endolditemize\enditemize
\renewenvironment{itemize}{%
    \smaller
    \olditemize
}{%
    \endolditemize
}
% Kod za definisanje checkmarka
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 
% Kod za definisanje inline koda
\providecommand{\inlinecode}[1]{\texttt{#1}}
% Kod za komandu koja uokviri tekst i na margini napise dodatnu informaciju u formatu \boxedimportant[info]{text}
\providecommand{\boxedimportant}[2][]{\noindent\fbox{%
            \parbox{\linewidth}{%
            #2            }%
                        \marginnote{#1}

            }
}
% Kod za horizontalnu liniju
\providecommand{\hzline}{\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}}
\addtolength{\topmargin}{-.875in}

\title{OOP1\\\large Objektno-orijentisano programiranje 1}
\author{Veljko Selaković }
\date{prof. dr Igor Tartalja\\ prof. dr Dragan Milićev}


\begin{document}

\maketitle
Ako nadjete greske recite mi odmah da ispravim
Nebitno da li su slovne ili sam nesto pogresno lupio. Mozete i sami izmeniti na https://github.com/veljkoselakovic/OOP1 i napraviti merge request
\newpage


\begin{itemize}
    \item \textbf{UML} - \textit{Unified Modeling Language} (Kasnije predmet \textit{Projektovanje softvera}, 5. semestar)
\end{itemize}
\section{Osnovni ciljevi OOP}
\begin{xitemize}
    \item Problem korišćenja postojećeg koda
    \begin{itemize}
        \item \textbf{Biblioteka funkcija} - skupo održavanje, otklanjanje grešaka i proširivanje sistema
    \end{itemize}
    \item Evolucija programskih jezika
    \begin{enumerate}
        \item Apstrakcija izraza  $\sim$1950. - \textbf{FORTRAN}
        \begin{itemize}
            \item Registri skriveni
        \end{itemize}
        \item Apstrakcija kontrole $\sim$1960. - \textbf{Algol60}
        \begin{itemize}
            \item Tok kontrole programa - \textit{petlje}
        \end{itemize}
        \item Apstrakcija podataka  $\sim$1970. - \textbf{Pascal}
        \begin{itemize}
            \item Razdvajanje detalja prezentacije podataka od apstraktnih operacija koje se definišu nad podacima - npr. \textit{tipovi nabrajanja}
        \end{itemize}
    \end{enumerate}
    \item Dodatni koncepti
    \begin{enumerate}
        \item Zasebno prevođenje modula - \textbf{FORTRAN, C, Ada}
        \item Razdvajanje interfejsa od implementacije - \textbf{Ada}
        \item Koncept klase - \textbf{Simula67}
    \end{enumerate}
    \item 4 Osnovna principa OOP
    \begin{itemize}
        \item Apstrakcija
        \item (En)kapsulacija
        \item \underline{Nasleđivanje}
        \item Polimorfizam
    \end{itemize}
\end{xitemize}
\section{C++}
\begin{xitemize}
    \item Razvoj C++
    \begin{itemize}
        \item  C $\rightarrow$ C sa klasama $\rightarrow$ C++
        \item Svake 3 godine novi standard
        \item ISO 98 $\rightarrow$ ISO 03 $\rightarrow$ ISO 11 $\rightarrow$ ISO 14 $\rightarrow$ISO 17 $\rightarrow$ ISO 20 \textit{(još nije standardizovano)}
        \item Spontani razvoj, za razliku od \textbf{Ade}
    \end{itemize}
    
    \item Aspekti C++
    \begin{enumerate}
        \item Da bude dovoljno \underline{blizak mašini}
        \begin{itemize}
            \item C++ je \textit{nadskup} u velikoj većini slučajeva
        \end{itemize}
        \item Da bude dovoljno \underline{blizak problemu}
        \begin{itemize}
            \item Klase iz \textbf{Simula67}
            \item Preklapanje operatora iz Algola
        \end{itemize}
    \end{enumerate}
\end{xitemize}
\newpage
\section{Pregled gradiva koje će se raditi}
\begin{xitemize}
    \item Klase i objekti
    \begin{itemize}
        \item Klase su apstrakcije zajedničkih atributa i zajedničkog ponašanja jednog skupa srodnih objekata
        \item Klasa sadrži
        \begin{enumerate}
            \item Podatke članove \textit{(atributi ili polja)}
            \item Funkcije članove \textit{(metodi)}
        \end{enumerate}
        \item Pristupačnost određenim članovima deklariše programer
        \item \textbf{Implementaciju} klase čine $\longleftarrow$ \textit{Kako radi?}
        \begin{enumerate}
            \item Privatni podaci članovi
            \item Definicije funkcija
        \end{enumerate}
        \item \textbf{Interfejs} klase čine $\longleftarrow$ \textit{Šta radi?}
        \begin{enumerate}
            \item Javni podaci članovi
            \item Deklaracije javnih funkcija 
        \end{enumerate}

        \item Instanca klase $\rightarrow$ objekat $\begin{cases}
        \textbf{Stanje}\\
        \textbf{Ponašanje}\\
        \textbf{Identitet}
        \end{cases}$
    \end{itemize}
    \item Konstruktori i destruktori
    \begin{itemize}
        \item Prilikom kreiranja i uništavanja objekta
        \item Nemaju \inlinecode{return} tip
        \item Automatsko izvršavanje prilikom kreiranja/uništavanja objekta
    \end{itemize}
    \item Izvođenje i nasleđivanje
    \begin{itemize}
        \item Iz opštije klase izvodimo specifične klase
        \item Izvedene klase nasleđuju atribute i metode osnovne klase, i dodaju nove
        \item Objekti izvedene klase su i indirektne instance osnovne klase
        \item U izrazima izvedeni objekti mogu zameniti osnovnu klasu - \textit{Liskov substitution principle}
        \item Nasleđeni metodi se mogu redefinisati
    \end{itemize}
    \item Polimorfizam
    \begin{itemize}
        \item Ako se funkcija proglasi \inlinecode virtual na nju se primeni \textbf{\underline{dinamičko vezivanje}}
        \item \textbf{\underline{Dinamičko vezivanje}} - Adresa se ne određuje u vreme povezivanja, poziv se vezuje za funkciju u vreme izvršenja
        \item Ponašanje objekta ne zavisi samo od tipa pokazivača, već i od tipa pokazanog objekta
    \end{itemize}
    
    \item Klasifikacija objektnih jezika
    \begin{enumerate}
        \item Objektno-bazirani
       \begin{itemize}
           \item Apstrakcija, (en)kapsulacija, modularnost\\ \textbf{Ada83, Visual Basic 6}
       \end{itemize} 
       \item Objektno-orijentisani
       \begin{itemize}
           \item Princip nasleđivanja\\
           \textbf{Simula, Smalltalk, Ada95, C++, Java, VB.Net, C\#}
       \end{itemize}
    \end{enumerate}
    \item Obrada izuzetnih situacija
    \begin{itemize}
        \item Nepostojeće datoteke, prekoračenje opsega indeksa,...
        \item Tradicionalni jezici u funkciji vraćaju vrednost koja signalizira grešku, koja se naknadno analizira
        \item Kod postane nepregledan
        \item   \inlinecode{try/catch/throw} ključne reči
    \end{itemize}
    \item Šabloni \textit{(Templates)}
    \begin{itemize}
        \item Određene obrade ne zavise od tipa podataka
        \item \textit{Generičko programiranje}
        \item Statički mehanizam - \textit{u prevodu se zameni}
    \end{itemize}
    \item Preklapanje operatora
    \begin{itemize}
        \item Sam koncept nije OO, ali se dobro uklapa
        \item Redefinicija standardnih jezičkih operatora
        \\   \inlinecode{operator<simbol>}
        \item Ne mogu se preklopiti svi operatori, a za neke važe posebna pravila
    \end{itemize}
\end{xitemize}

\section{Proširenja jezika C}
\begin{xitemize}

    \item Deklaracija vs definicija
    \begin{multicols}{2}
    \begin{itemize}
    
        \item Deklaracija je iskaz koji
        \begin{enumerate}
            \item Uvodi ime u program
            \item Govori prevodiocu kojoj jezičkoj kategoriji pripada ime
        \end{enumerate}
        \item Definicija
        \begin{enumerate}
            \item Kreira objekat ILI
            \item Navodi telo funkcije ILI
            \item U potpunosti navodi strukturu korisničkog tipa
        \end{enumerate}
        
    
    \end{itemize}
    \columnbreak
    \begin{lstlisting}
    void f(int x, float y);       // Deklaracija
    void f(int x, float y) {...} // Definicija
    extern int x; // Deklaracija
    int x; //Definicija
    class X; //Deklaracija
    class X { ... }; //Definicija
    \end{lstlisting}
    \end{multicols}
    \begin{itemize}
        \item Samo jedna definicija, a proizvoljno mnogo deklaracija
        \item Objekat može biti definisan i deklarisan u istom redu
    \end{itemize}
    \item Objekti
    \begin{itemize}
        \item Objekat u širem smislu - \textbf{podatak}
        \item Objekat u užem smislu - \textbf{instanca klase}
        \item Objekat ima 
        \begin{enumerate}
            \item Stanje
            \item Ponašanje
            \item Identitet $\rightarrow$ primitivni podaci nemaju identitet
        \end{enumerate}
        \item \textbf{Promenljiva} je lokacija u kojoj se čuva podatak
        \item Podela promenljivih
        \begin{enumerate}
            \item Statička
            \item Automatska
            \item Dinamička
            \item Privremena \textit{(tranzijentna)}
        \end{enumerate}
    \end{itemize}
    \begin{multicols}{2}
    \item Lvrednosti \textit{(LVALUE)}
    \begin{itemize}
        \item Izraz koji upućuje na objekat ili funkciju
        \item Operatori čiji operandi moraju biti LVAL \\
        \textbf{unarni  \inlinecode{\&, ++, --,} levi operandi svih operatora dodele}
        \item Operatori čiji su rezltati LVAL\\
        \textbf{unarni   \inlinecode{*, [],} prefiksni   \inlinecode{++} i   \inlinecode{ --,} operatori dodele}
        \item DVrednost je sve što nije LVrednost \textit{(RVALUE)}
    \end{itemize}
    \columnbreak
    \begin{lstlisting}
    int *q[100]; 
    q[10]=&i;  //q[10] je lvrednost
    *q[10]=1; // *q[10] je lvrednost 
    q = &i; // ERROR, ime niza nije vrednost
    int a=1, b=2, c=3;
    (a=b)=c; // OK
    (a+b)=c; // ERROR
    ++ ++i; // OK
    i++ ++; // ERROR
    \end{lstlisting}
    \end{multicols}


\newpage
    \item Oblast važenja
    \textit{(Scope)}
    \begin{itemize}
        \item Onaj deo teksta programa u kome se deklarisano ime može koristiti
        \item \textbf{\underline{Dinamičko vezivanje}} imena $\rightarrow$ od mesta deklaracije do kraja datoteke (globalna imena)
        \item \textbf{Lokalna} imena $\rightarrow$ od mesta deklarisanja do kraja odgovarajućeg bloka
        \item Sakrivanje imena 
        \begin{enumerate}
            \item  Ako se definiše u nekom bloku, globalno je skriveno
            \item \boxedimportant[BITNO]{Ako se redefiniše u unutrašnjem bloku, ime iz spoljašnjeg bloka je sakriveno do izlaska iz bloka}
        \end{enumerate}
        \item Pristup globalnom imeu koristeći operator  \inlinecode{::}
    \end{itemize}
    \begin{lstlisting}
    int x = 0; // Globalno x
    void f() {
        int y=x, x; // y dobija vrednost globalnog x
        x=1; // Lokalno x
        ::x=5; // Globalno x
        {
            int x; // Novo lokalno x, sakriva prethodno
            x=2;
        }
        x=3; // Pristup prvom lokalnom
    }
    int *p = &x; // Globalno x
    \end{lstlisting}


    \item Specifični dosezi
    \begin{itemize}
        \item Oblast važenja funkcije imaju samo labele
        \item  \inlinecode{for} petlja
        \item Ranije verzije kompajlera su imale doseg promenljivih koji je bio 1 blok \textbf{van}  \inlinecode{for} (MS VC++.6)
        \item U  \inlinecode{if} doseg do kraja  \inlinecode{else}
    \end{itemize}
    \item Klasni/Strukturni doseg
    \begin{itemize}
        \item Oblast važenja imaju svi njeni članovi
        \begin{enumerate}
            \item  \inlinecode{.} $\rightarrow$ levi operand objekat
            \item   \inlinecode{->} $\rightarrow$ levi operand pokazivač na objekat
            \item  \inlinecode{::} $\rightarrow $ levi operand ime klase
        \end{enumerate}
    \end{itemize}
    \item Životni vek objekata
    \begin{itemize}
        \item Vreme u toku izvršavanja programa u kojem objekat postoji i za koje mu se može pristupati
        \item Vek atributa klase = vek objekta
        \item Vek parametra = vek automatskog objekta
        \begin{enumerate}
            \item Statički objekti
            \item Automatski objekti
            \item Dinamički objekti
            \item Privremeni \textit{(tranzijentni)} objekat
        \end{enumerate}
    \end{itemize}
    \item Statički i automatski objekti
    \begin{itemize}
        \item Automatski objekat je lokalni objekat koji nije definisan kao \textit{static}
        \begin{enumerate}
            \item \textbf{Životni vek} - od definicije do kraja oblasti važenja
            \item Svaki put se kreira iznova prilikom poziva bloka u kom je definisan
            \item Prostor se alocira na \textit{stack}
        \end{enumerate}
        \item Statički objekat je globalni objekat ili lokalni deklarisan kao \textit{static}\\\\
        Globalni 
        $\begin{cases}
        $1. \textbf{Životni vek} - od definicije do kraja izvršenja \textit{main}$\\
        $2. Kreiraju se jednom, na početku izvršavanja, pre funkcija objekta$\\
        \end{cases}$\\
        Lokalni\hspace{0.26cm}$\begin{cases}
        $3. Počinju da žive pri prvom nailasku na njih$
        \end{cases}$
    \end{itemize}
    \newpage
    \item Dinamički i privremeni objekti
    \begin{itemize}
        \item Dinamički objekti se kreiraju i uništavaju posebnim operacijama
        \begin{enumerate}
            \item \textbf{Životni vek} - kontroliše programer
            \item   \inlinecode{new/delete}
            \item Prostor alocira na \textit{heap}
        \end{enumerate}
        \item Privremeni objekti se kreiraju pri izračunavanju izraza
        \begin{enumerate}
            \item \textbf{Životni vek} - kratak i nedefinisan
            \item Odlaganje međurezultata i privremeno smeštanja vraćenih vrednosti funkcije
            \item Najčešće se uništavaju čim nisu potrebni
        \end{enumerate}
    \end{itemize}


    \item Leksički elementi
    \begin{itemize}
        \item Komentari
        \begin{enumerate}
            \item \inlinecode{$//...$}
            \item \inlinecode{$/*...*/$}
        \end{enumerate}
        \item 73 ključne reči + alternative
        \item C++11 \inlinecode{bool}, C11:  \inlinecode{\_Bool}
        \item Specijalne (ali ne i rezervisane) reči: \inlinecode{final} i  \inlinecode{override} \textit{(Backwards compatibility)}
        \item Ne treba započinjati imena donjom crtom
    \end{itemize}

\item Tipizacija
\begin{itemize}
    \item \textbf{Stroga tipizacija} - objekti različitih tipova se ne mogu proizvoljno zamenjivati
    \item C++ je hibridan
    \begin{enumerate}
        \item Za osnovne primitivne tipove \checkmark{}
        \item Za sve ostalo X
    \end{enumerate}
\end{itemize}
\item Konverzija
\begin{itemize}
    \item Operatori zahtevaju određene tipove operanada
    \item Naredbe zahtevaju određene tipove operanada \\
    \inlinecode{for, if, while...}
\end{itemize}
\item Vrste konverzija tipova
\begin{itemize}
    \item \textbf{Standarna konverzija} - ugrađeno u jezik\\
    npr. \inlinecode int $\rightarrow $ \inlinecode float, \inlinecode char $\rightarrow$ \inlinecode int
    \item \textbf{Korisnička konverzija} - definiše programer
    \item Pored toga, konverzija može biti
    \begin{enumerate}
        \item \textbf{Implicitna} - prevodilac je automatski vrši
        \item \textbf{Eksplicitna} - zahteva programer
    \end{enumerate}
    \item C koristi \textit{cast} operator \\
    \inlinecode{(tip)izraz}
    \item C++ uvodi 4 specifčna \textit{cast} operatora
    \item Postoji i konverzioni konstruktor
\end{itemize}
\item Priduživanje imena tipu
\begin{multicols}{2}

\begin{itemize}
    \item C-stil\\
    \inlinecode{typedef opis\_tipa = ime\_tipa}
    \item C++ stil, čitljivije\\
    \inlinecode{using ime\_tipa = opis\_tipa}
\end{itemize}
\columnbreak
    \begin{lstlisting}
typedef unsigned long long int Ceo1;
using Ceo2 = unsigned long long int; 
    \end{lstlisting}
\end{multicols}
\begin{multicols}{2}

\item Određivanje tipa izrazom\newline
\inlinecode{decltype (izraz) promenljiva [= vrednost]}
\begin{itemize}
    \item Izraz se \textbf{ne} izračunava
    \item Primena kod \textit{template-ova}
\end{itemize}
\columnbreak
\begin{lstlisting}
int x=1; double y=2.3;
decltype(x) a = x; // a je int
decltype(y) b = y; // b je float
decltype(a++) c = a; // c == a == 1
\end{lstlisting}
\end{multicols}
\item Automatsko određivanje tipa
\begin{itemize}
    \item \inlinecode{auto} ključna reč određuje tip na osnovu inicijalne vrednost 
    \inlinecode U C, \inlinecode{auto} označava automatsku lokalnu promenljivu, i ne piše se
    
    \begin{lstlisting}
auto int a = 10; // Samo u C
auto a = 10; // C++, a je int
\end{lstlisting}
\end{itemize}

\item Odloženo navođenje tipa funkcije\\
\inlinecode{auto ime\_funkcije(parametri) -> tip}
\begin{itemize}
    \item Koristi se kod \textit{template-ova}
    \item C++14 \inlinecode{tip} može da se izostavi
    \begin{enumerate}
        \item U tom slučaju tip se odredi preko \inlinecode{return} tipa ili definicije
        \item Funkcija ne sme da se poziva pre navođenja definicija na mestima gde je tip bitan
    \end{enumerate}
    \begin{lstlisting}
auto func(int x) -> double { ... } // return tip je double
auto f() { return 1; }
auto g();
auto a = g(); // ERROR
auto g() { return 0.5}
auto b = g() // OK
    \end{lstlisting}
\end{itemize}
\item Konstante
\begin{itemize}
    \item Izvedeni tip\\
    \inlinecode{const tip ime = vrednost;}
    \item Mora da se inicijalizuje pri definisanju
    \item Izraz ne morada bude konstantan
    \item \boxedimportant[BITNO]{Konstante inicijalizovane \textbf{konstantnim} izrazom
    (\textit{simboličke} ili \textit{kompilacione} konstante) mogu da se koriste u izrazima koji moraju biti konstantni (računaju se \textbf{u toku} prevođenja)\\
    npr. Dimenzija statičkog niza}
    
    \item \textbf{Simboličke }konstante NE alociraju memoriju
    \\\\
    \inlinecode{const char* pk = niz;} $\longleftarrow$ pokazivač na konstantu\\
    \inlinecode{char* const kp = niz;} $\longleftarrow$ konstantni pokazivač
    \item Ubacivanje \inlinecode{const} u parametre funkcije obezbeđuje da se dati objekat ne menja
    \item Ubacivanje \inlinecode{const} u \inlinecode{return} tipu funkcije obezbeđuje da se privremeni objekat rezultata ne može menjati
    \item POGLEDATI \inlinecode{constexpr}
    \begin{lstlisting}
char niz[] = { 'i', 'd', 'e', ' ', 'g', 'a', 's', '\0' };
const char* pk = niz; // Pokazivac na konstantu
pk[3] = '-';            // ERROR
pk = "OOP:(";          // OK
char* const pk = niz    // Konstantni pokazivac
pk[3] = '-';            // OK
pk = "OOP:(";          // ERROR
    \end{lstlisting}
\end{itemize}
\item Znakovne konstante
\begin{itemize}
    \item U C $\rightarrow$ \inlinecode int (\inlinecode 65 i \inlinecode 'A' su ista stvar)
    \item U C++ $\rightarrow$ \inlinecode char
    \item U izrazima \inlinecode{false} $\rightarrow$ 0, a u dodeli vrednosti logičkim promenljivama 0 $\rightarrow$ \inlinecode{false}
\end{itemize}
\newpage

\item Prostori imena (\inlinecode{namespace})
\begin{itemize}
    \item Mehanizam za izbegavanje konflikata imena\\
    \inlinecode{namespace ID \{ sadržaj \}}
    \item Jednoznačno ime
    \begin{enumerate}
        \item Celo ime \inlinecode{A::i}
        \item Uvoz imena \inlinecode{using A::i}
        \item Uvoz svih imena \inlinecode{using namespace A}
    \end{enumerate}
\end{itemize}
\item Stringovi
\begin{itemize}
    \item C stil - niz znakova koji se završava sa \inlinecode{$\backslash$0}
    \item Literal C++ stringa je \inlinecode{const char*}
    \item Literal C stringa je \inlinecode{char*}
    \item C++ - podrazumevani string je \inlinecode{""}
\end{itemize}
\item Tipovi \inlinecode{enum}, \inlinecode{struct} i \inlinecode{union}
\begin{itemize}
    \item Identifikatori ova 3 tipa mogu da se koriste kao oznaka tipa, bez ključne reči
    \item Ako u dosegu postoji objekat sa istim identifikatorom, sam ID označava objekat, a ne tip
    \begin{lstlisting}
enum RadniDan {Pon, Uto, Sre, Cet, Pet};
RadniDan r_dan = Uto;
int RadniDan;
enum RadniDan r1 = Sre; // OK
RadniDan r1 = Pon;        // ERROR
    \end{lstlisting}
\end{itemize}


\item Tip nabrajanja (\inlinecode{enum})
\begin{itemize}
    \item Svaki \inlinecode{enum} je poseban celobrojni tip
    \item Definisana je samo operacija dodele vrednosti
    \begin{enumerate}
        \item \boxedimportant[BITNO]{Eksplicitna konverzija celobrojne vrednosti u tip nabrajanja je obavezna}
        \item Ne otkriva se greška ako konvertovana vrednost nije u opsegu 
    \end{enumerate}
    \item U aritmetičkim i relacijskim izrazima, kao i pri dodeli promenljivoj tipa int, konverzija je automatska
    \begin{lstlisting}
enum Dani {PO=1, UT, SR, CE, PE, SU, NE, POSLEDNJI=7}; // NE i POSLEDNJI su 7
Dani dan=SR; // OK
Dani d=4; // ERROR - nije eksplicitna konverzija
dan++; // ERROR - nije definisana operacija ++
dan=(Dani)(dan+1); // OK
if (dan<NE) { ... } // OK
dan=(Dani)8; // Ne prijavljuje se logicka greska
    \end{lstlisting}
\end{itemize}
\item Pripadajući tip nabrajanja
\begin{itemize}
    \item Numerička reprezentacija nabrajanja
    \item Kompaktnije, podrazumeva se int\\
    \inlinecode{enum ime: pripadajući\_tip \{imenovane\_konstante\}}
    \item Paziti opsege
\end{itemize}
\begin{multicols}{2}
\item Nabrajanja sa ograničenim dosegom
\begin{itemize}
    \item Isti doseg kao i tip nabrajanja
    \item Rešenje - \inlinecode{struct} ili \inlinecode{class} iza \inlinecode{enum} 
    \item Pristup konstanti sa \inlinecode{::}
    \item Obavezna eksplicitna konverzija u ceo broj\\
    \inlinecode{int i = (int)tip::ime}
\end{itemize}
\columnbreak
\begin{lstlisting}
enum SemaforPesaci {CRVENO, ZELENO};
enum SemaforVozila {ZELENO, ZUTO, CRVENO}; // ERROR
enum struct SemaforPesaci {CRVENO, ZELENO};
enum struct SemaforVozila {ZELENO, ZUTO, CRVENO};
SemaforPesaci sp = SemaforPesaci::CRVENO;
SemaforVozila sv = ZUTO; // ERROR
int i = (int) SemaforVozila::ZELENO; // Obavezna konverzija
\end{lstlisting}
\end{multicols}
\item Inicijalizatorske liste\\
\inlinecode{\{vrednost, vrednost, ..., vrednost\}}
\begin{itemize}
    \item Inicijalizacija \textbf{svih} vrsta podataka, čak i prostih
    \item Paziti na nebezbedne konverzije
    \item Vrednosti se dodeljuju redom (čak i strukturama, uniji se popuni prvo polje)
    \item Manjak vrednosti $\rightarrow$ popunjava se nulama
    \item Višak vrednosti $\rightarrow$ Greška
    \item Argumenti funkcija i izrazi u \inlinecode{return} mogu biti ove liste
    \item Bezimeni podatak
    \item \boxedimportant[ČUDNO]{Niz ne može da dobije vrednost liste nakon inicijalizacije, sem ako je deo neke strukture}
    \begin{lstlisting}
int i1={1}, i2{1}, i3={i1+i2};
i1={2};
int i4={0.5}; // ERROR - nije bezbedno
int *pi={&i1};
int n1[5]={1,2,3}, n2[5]{1,2,3}, n3[]{1,2,3};
int m[][3]{{1,2},{},{1,2,3}};
n1={4,5,6}; // ERROR
struct S1{int a,b;};
S1 s11={1,2}, s12{1,2}; s11={3,4};
struct S2{int a; S1 b; int c[3];};
S2 s21={1,{2,3}, {4,5,6}}, s22{1,2,3,4,5,6};
s21 = {6, {5,4}, {3,2,1}}; 
    \end{lstlisting}
\end{itemize}
\item Bezimena unija
\begin{itemize}
    \item Predstavlja objekat koji sadrži u raznim trenucima razne tipove podataka
    \item Datotečki ili blokovski doseg
    \item Unija za koju je definisan barem 1 objekat ili pokazivač $\rightarrow$ nije bezimena unija, iako nema ime
    \begin{lstlisting}
union{ int i; double d; char *pc; };
i=55; d=123.456; pc="ABC";
    \end{lstlisting}
\end{itemize}

\item Uvek promenljiva polja (\inlinecode{mutable})
\begin{itemize}
    \item Polje označeno sa \inlinecode {mutable} može da se menja čak i za \inlinecode {const} parametre
    \begin{lstlisting}
struct X{
    int a;
    mutable int b;
};
int main(){
    X x1;
    const X x2;
    x1.a = 4;
    x1.b = 2;
    x2.a = 3; // ERROR
    x2/b = 4; // OK
}
    \end{lstlisting}
\end{itemize}

\newpage
\item Dinamički objekti
\begin{itemize}
    \item \inlinecode {new/delete}
    \item Operand operatora \inlinecode {new} je identifikator tipa \inlinecode T sa eventualnim inicijalizatorima
    \begin{enumerate}
        \item Alocira potreban prostor za objekat datog tipa
        \item Poziva konstruktor tipa
    \end{enumerate}
    \item Ako nema mesta \inlinecode {bad\_alloc} exception\\
    U nestandardizovanom C++ vraća se \inlinecode {nullptr}
    \item Vraća pokazivač na kreirani objekat\\
    \inlinecode{T *t = new (nothrow)T;} $\longleftarrow$ Ignorisanje exceptiona, vraća \inlinecode{nullptr} ako ne uspe
    \item Stavlja na \textit{heap}
\end{itemize}
\item Uništavanje dinamičkih objekata
\begin{itemize}
    \item \inlinecode {delete} ima 1 operand (pokazivač nekog tipa)
    \item Mora biti objekat kreiran pomoću \inlinecode {new}, inače će ponašanje biti nepredviđeno
    \item  \inlinecode{delete nullptr} ne radi ništa
    \begin{enumerate}
        \item Poziva destruktor za pokazani objekat
        \item Oslobađa zauzeti prostor
    \end{enumerate}
    \item \inlinecode {delete} vraća \inlinecode {void}
\end{itemize}
\item Dinamički nizovi
\begin{itemize}
    \item Sve dimenzije niza osim prve moraju biti konstanti izrazi
    \item Inicijalizacija
    \begin{enumerate}
        \item Podrazumevani konstruktor ILI
        \item Generisain konstruktor
    \end{enumerate}
    \inlinecode{delete [] pt;}
    \item Redosled konstrukcije po rastućem indeksu
    \item Redosled destrukcije obrnut od redosleda konstrukcije
    \item Može inicijalizatorska lista
\end{itemize}


\item Reference
\begin{itemize}
    \item C isključivo po vrednosti prenosi argumente
    \item C++ prenosi argumente i po referenci
    \begin{lstlisting}
void f(int i, int &j){ // i po vrednosti, j po referenci
    i++; // stvarni argument se nece promeniti
    j++; // stvarni argument ce se promeniti
}
int main () {
    int si=0,sj=0;
    f(si,sj);
    cout<<"si="<<si<<", sj="<<sj<<endl;
}
Izlaz: si=0, sj=1
    \end{lstlisting}
\end{itemize}
\item Definisanje referenci
\begin{itemize}
    \item Reference na LVrednosti (\inlinecode {lvalue})
    \item Znak \inlinecode\& ispred imena
    \item Sinonim za objekat, ne može se promeniti
    \item U definiciji mora da se inicijalizuje objektom
    \item Svaka naredba nad referencom je operacija nad pokazanim objektom
    \begin{lstlisting}
int i=1; // celobrojni objekat i
int &j=i; // j upucuje na i
i=3; // menja se i
j=5; // opet se menja i
int *p=&j; // isto sto i &i
j+=1; // isto sto i i+=1
int k=j; // posredan pristup do i preko reference
int m=*p; // posredan pristup do i preko pokazivaca
    \end{lstlisting}
\end{itemize}


\item Implementacija referenci
\begin{itemize}
    \item Slično konstanom pokazivaču\\
    \inlinecode{int \&j = *new int(2);}\\
    \inlinecode{delete \&j;}
    \item Ako je referenca na \inlinecode {const} objekat, ne sme se menjati 
    \item Ne postoje nizovi referenci, pokazivači na referencu, kao ni reference na reference
    \item Referenca na pokazivač je dozvoljena
\end{itemize}


\item Funkcije koje vraćaju reference
\begin{itemize}
    \item Funkcija mora da vrati referencu na objekat koji je \textit{živ} i posle funkcije
    \item Rezultat poziva funkcija je LVrednost (\inlinecode {lvalue}) samo kao funkcija vraća referencu
    \begin{lstlisting}
int& f(int &i) { int &r = *new int(i); return r; } // OK
int& f(int &i) { return *new int(i); } // OK
int& f(int &i) { return i; } // OK
int& f(int &i) { int r = i; return r;} // NIJE OK
int& f(int i) { return i; } // NIJE OK
int& f(int &i) { int r = *new int(i); return r; } // NIJE OK
int& f(int &i) { int j = i; &r = j; return r; } // NIJE OK
    \end{lstlisting}
\end{itemize}
\item Obilazak elemenata niza u petlji\\
\inlinecode{for(tip ime: niz) naredba}
\begin{itemize}
\item \textbf{foreach}, range petlja
\item Može se staviti referenca na objekat, čime omogućavamo menjanje svakog elementa kom pristupamo - bez njega su \textit{read-only}
\begin{lstlisting}
for(auto& it: arr){ // it od iterator
    cout<<it++<<endl;
}
\end{lstlisting}

\end{itemize}
\begin{multicols}{2}
\item Reference na DVrednosti (\inlinecode {rvalue})
\begin{itemize}
    \item Tip reference na DVrednost\\
    \inlinecode{osnovni\_tip \&\& ime = vrednost;}
    \item Referenca na DVrednost je LVrednost
    \item Posledica - privremeni podaci dobijaju imena, pa možemo da ih menjamo
    \item Podatak može biti nepromenljiv
\end{itemize}
\columnbreak
\begin{lstlisting}
int i=1; // i je promenljiv podatak
const int ci=i; // ci je nepromenljiv podatak
int && rd1=i; // ERROR - i je promenljiva lvrednost
int && rd2=ci; // ERROR - ci je nepromenljiva lvrednost
int && rd3=i+1; // (i+1) je promenljiva dvrednost
int && rd4=10; // 10 je nepromenljiva dvrednost 
rd3++; rd4++; // rd3==3, rd4==11 
\end{lstlisting}
\end{multicols}
\item Reference na DVrednosti kao parametri
\begin{itemize}
    \item Ne postoji \textit{bočni efekat}
    \item \inlinecode {const} nema smisla
\end{itemize}
\item Podrazumevane vrednosti argumenata
\begin{itemize}
    \item Može biti samo nekoliko poslednjih argumenata
    \item Proizvoljni izrazi
\end{itemize}
\newpage

\item Neposredno ugrađivanje funkcije u kod
\begin{itemize}
    \item Jednostavne, kratke funkcije\\
    \inlinecode{inline tip ime( parametri ) \{ definicija }\}
    \item Izbegavanje prenosa argumenata i poziva funkcija
    \item Funkcija članica klase je \inlinecode {inline} ako se definiše u definiciji klase
    \item Ako se definiše van definicije klase, mora se staviti ključna reč
    \item Prevodilac ne mora da poštuje \inlinecode {inline}
    \item Ako je u više datoteka, mora se definisati u svakoj
    \item Često rešenje je sprovođenje sa dodatnom datotekom-zaglavljem, ali se tad funkcija može direktno videti od strane drugih korisnika
    \item Eliminiše potrebu za makroima
    \begin{lstlisting}
#define max(i,j)((i)>(j))?(i):(j)
max(i++, k++);
((i++)>(j++))?(i++):(j++); // 2x se inkrementira
    \end{lstlisting}
\end{itemize}

\item Preklapanje imena funkcija
\begin{itemize}
    \item \textit{Function name overloading}
    \item Funkcije koje realizuju logički istu operaciju, sa različitim tipovima argumenata
    \item U C nema preklapanja - funkcije moraju imati različita imena
    \item Mora da se razlikuje broj i/ili tip argumenata
    \item Tip rezultata \textbf{ne mora} da se razlikuje
    \item Takođe, \textbf{nije dovoljno} da se razlikuje samo \inlinecode{return} tip
    \item Statički koncept, sve se odvija u prevođenju
    \item Prevodilac prioritira slaganje tipova
    \begin{enumerate}
        \item Potpuno slaganje - uključuje niz $\rightarrow$ pokazivač, ili referenca $\rightarrow$ objekat
        \item Slaganje standardnim konverzijama\\
        npr. \inlinecode{char} $\rightarrow$ \inlinecode{int}
        \item Slaganje korisničkim konverzijama
    \end{enumerate}
    \begin{lstlisting}
double max (double i, double j)
{ return (i>j) ? i : j; }
const char* max (const char *p, const char *q)
{ return (strcmp(p,q)>=0)?p:q; }
double r=max(1.5,2.5); // max(double,double)
double p=max(1,2.5); // (double)1; max(double,double)
const char *q=max("Pera","Mika");// max(const char*,const char*)
    \end{lstlisting}
\end{itemize}

\item Pristup elementima
\begin{itemize}
    \item Složeni podaci
    \item Problem 2 definicije koje imaju identično telo sa različitim parametrima
    \item Druga funkcija poziva prvu $\longleftarrow$ Rešenje
    \item Slično za pokazivače i reference
    \item Čudan slajd, izgleda kao dodatno objašnjavanje overloadinga
    \begin{lstlisting}
int& elem( int *a, int i) { return a[i]; }
const int& elem(const int *a, int i) { return a[i]; }
int a[20],i=10;
const int b[20]={0};
elem(a,i)=1;
elem(b,i)=1; // ERROR
int x=elem(b,i);
    \end{lstlisting}
\end{itemize}
\newpage
\item Napomene 
\begin{itemize}
    \item Uputstva za prevodioca, \textbf{anotacije}\\
    \inlinecode{[[napomena]]}
    \item Služe prevodiocu za provere i optimizacije
    \item Prevodilac može da ih zanemari
\end{itemize}
\item Funkcije koje se ne vraćaju
\begin{itemize}
    \item Postoje funkcije koje se ne vraćaju na mesto poziva
    \item Nasilno prekida rad programa sa \inlinecode{exit(kod)}
    \begin{enumerate}
            \item Kod = 0 \checkmark{}
            \item Kod $\neq$ 0 X
    \end{enumerate}

    \item Anotacija \inlinecode{[[noreturn]]}
    \item Ako ima negde \inlinecode{return}, kod postaje nepredvidiv
\end{itemize}
\item Operatori i izrazi
\begin{itemize}
    \item Novi operatori (12)
    \begin{itemize}
        \item[] unarni \inlinecode{::, ::, new, delete, .*, ->*, typeid, throw, alignof}, 4 \textit{cast} operatora
    \end{itemize}
    \item Postfiksni \inlinecode{++, --} imaju viši prioritet od prefiksnih
    \item Prefiksni \inlinecode{++, --} $\rightarrow$ \inlinecode{lvalue}
    \item Dodela vrednosti $\rightarrow$ \inlinecode{lvalue}
    \item Ternarni operator je \inlinecode{lvalue} ako su drugi i treći operator \inlinecode{lvalue}
\end{itemize}


\item Operatori konverzije tipa
\begin{itemize}
    \item C \textit{cast} \\
    \inlinecode{(tip) izraz} $\longleftarrow$ Ne preporučuje se
    \item Novi \textit{cast} operatori
    \begin{enumerate}
        \item \inlinecode{static\_cast <oznaka\_tipa> (izraz)}
        \item \inlinecode{reinterpret\_cast <oznaka\_tipa> (izraz)}
        \item \inlinecode{const\_cast <oznaka\_tipa> (izraz)}
        \item \inlinecode{dynamic\_cast <tip\_pokazivača\_ili\_reference> (izraz)}
    \end{enumerate}
    \item Bezbedne i nebezbedne konverzije\\
    \inlinecode{int} $\rightarrow$ \inlinecode{float} \checkmark{}\\
    \inlinecode{float} $\rightarrow$ \inlinecode{int} X
    \item Notacija je nezgrapna i kabasta iz 2 razloga
    \begin{enumerate}
        \item Lakše se uoči u tekstu
        \item Da programeri ne bi koristili
    \end{enumerate}
    \item Ako postoji potreba za eksplicitnim konverzijama $\rightarrow$ Preispitati projektne odluke
\end{itemize}
\item Statička konverzija
\begin{itemize}
    \item Prenosive konverzije
    \begin{enumerate}
        \item Između numeričkih tipova
        \item Između pokazivača i \inlinecode{void*}
        \item Nestandardne konverzije - definiše programer
    \end{enumerate}
    \item Primenjuju se automatski kad su bezbedne
    \item Eksplicitan poziv kad je nebezbedno\\
    npr. \inlinecode{void*} $\rightarrow$ drugi pokazivač, numerički tip $\rightarrow$ \inlinecode{char}
    \item \inlinecode{nullptr} može da se dodeli bilo kom tipu pokazivača
    \item Ne preporučuje se korišćenje \inlinecode{NULL} ili \inlinecode0
\end{itemize}
\item Reinterpretirajuća konverzija
\begin{itemize}
    \item Konverzija tipova bez logičke veze\\
    npr. \inlinecode{int} $\rightarrow$ pokazivač
    \item Nema pretvaranja vrednosti, istu vrednost različito interpretiramo
    \item Jako nebezbedno
\end{itemize}
\item Konstanta konverzija
\begin{itemize}
    \item Dodavanje ili uklanjanje \inlinecode{const}
    \item Dodavanje je bezbedno, uklanjanje nije
\end{itemize}
\end{xitemize}
\newpage

\section{Klase i objekti}
\begin{xitemize}
\item Osnovni pojmovi
\begin{itemize}
    \item Klasa je struktuirani korisnički tip koji obuhvata
    \begin{enumerate}
        \item Podatke koji opisuju stanje objekta klase
        \item Funkcije namenjene definisanju operacija nad podacima
    \end{enumerate}
    \item Klasa je formalni opis aptrakcije koja ima
    \begin{enumerate}
        \item Internu implementaciju
        \item Javni interfejs
    \end{enumerate}
    \item Instanca klase $\rightarrow$ objekat
    \item Podaci klase $\rightarrow$ \textbf{atributi}, polja, podaci članovi
    \item Funkcije klase $\rightarrow$ \textbf{metodi}, primitivne operacije, funkcije članice
\end{itemize}
\item Komunikacija objekata
\begin{itemize}
    \item Objekti klasa komuniciraju da ostvare složene funkcije
    \item Poziv metoda $\rightarrow$ \textbf{upućivanje poruke}
    \item Objekat može da menja stanje kad se pozove metod
    \item \textbf{Objekat-klijent} - poziva metod
    \item \textbf{Objekat-server} - metod mu je pozvan
    \item Iz svog metoda se može pozvati metod drugog objekta iste ili druge klase
    \item Unutar metode, članovima objekta-servera pristupa se navođenjem imena
\end{itemize}
\item Pravo pristupa
\begin{itemize}
    \item Sekcije
\end{itemize}
\begin{enumerate}
    \item \inlinecode{private}
    \begin{itemize}
        \item Zaštićeni od spolja (\textbf{kapsulirani})
        \item Pristupaju im samo metodi klase
    \end{itemize}
    \item \inlinecode{protected}
    \begin{itemize}
        \item Dostupni metodima iste klase + sve klase izvedene iz nje
    \end{itemize}
    \item \inlinecode{public}
    \begin{itemize}
        \item Dostupni spolja bez ograničenja
    \end{itemize}
\end{enumerate}
\begin{itemize}
    \item Preporučuje se redosled \inlinecode{private} $\rightarrow$ \inlinecode{protected} $\rightarrow$ \inlinecode{public}
    \item Može da postoji više sekcija iste vrste
    \item Podrazumevana labela je \inlinecode{private}

\item \boxedimportant[BITNO]{Kontrola pristupa je stvar klase, a ne objekta\\
Metod jednog objekta može da pristupa privatnim članovima drugog objekta iste klase}
\item Kontrola pristupa je odvojena od koncepta dosega
\begin{enumerate}
    \item Odredi se postojanje
    \item Proveravanje prava pristupa
\end{enumerate}
\end{itemize}
\newpage
\item Definisanje klase
\begin{itemize}
    \item Atributi
    \begin{enumerate}
        \item Mogu da budu i inicijalizovane - od C++11
        \item Ne moguda budu tipa klase koja se definiše, ali su dozvoljeni pokazivači i reference na tu klasu
    \end{enumerate}
    \item Metodi
    \begin{enumerate}
        \item U definiciji mogu da se 
        \begin{itemize}
            \item[-] Deklarišu - samo prototip
            \item[-] Definišu - kompletno telo
        \end{itemize}
        \item Funkcije definisane u definiciji klase su \inlinecode{inline} i mogu pristupati članovima imenom
        \item Funkcije koje su samo deklarisane u definiciji klase moraju biti definisane kasnije, van definicije, sa proširenim dosegom za pristup članovima\\
        \inlinecode{<ime\_klase>::<ime\_funkcije>}
        \item Vrednost rezultata metoda može biti tipa klase koja se definiše, kao i pokazivač ili referenca na nju
    \end{enumerate}
    \item Definicija se piše tamo gde se klasa koristi, obično u \textit{header} fajl (\inlinecode{.h})
    \item Nepotpuna definicija klase je \textbf{deklaracija}
    \item Pre defincije, a posle deklaracije
    \begin{enumerate}
        \item Mogu da se definišu pokazivači i reference
        \item Ne mogu da se definišu objekti te klase
    \end{enumerate}
\end{itemize}
\item Objekti klase
\begin{itemize}
    \item Uobilajeno definisanje, kao kod standardnih tipova
    \item Za svaki objekat formira se poseban komplet svih nestatičkih atributa
    \item Nestatički metodi se pozivaju za objekte, a statički za klase
    \item  Lokalne \inlinecode{static} promenljive metoda
    \begin{enumerate}
        \item Zajedničke za sve objekte
        \item Žive od nailaska na njih do kraja programa
        \item \boxedimportant[WTF]{Imaju svojstva lokalnih promenljivih globalnih funkcija}
    \end{enumerate}
\end{itemize}
\item Podrazumevane operacije
\begin{itemize}
    \item Definisanje objekata, pokazivača i referenci na objekte i nizove objekata
    \item Dodela vrednosti jednog objekta drugo
    \item Uzimanje adrese \inlinecode\&
    \item Pristupanje objektu preko pokazivača \inlinecode*
    \item Pristupanje atributima i pozivanje metode neposredno pomoću \inlinecode.
    \item Pristupanje atributima i pozivanje metoda posredno pomoću pokazivača \inlinecode{->}
    \item Pristupanje elementima niza \inlinecode{[]}
    \item Prenošenenje objekta kao argumenata po vrednosti, referenci ili pokazivaču
    \item Vraćanje objekta iz funkcije po vrednosti, referenci ili pokazivaču
    \item Preklapanje operatora može redefinisati dosta gorenavedenog
\end{itemize}


\item Pokazivač \inlinecode{this}
\begin{itemize}
    \item Pokazivač na tekući objekat
    \item Unutar svako nestatičkog objekta je implicitno, \inlinecode{this} je skriveni argument svakog metoda\\
    \inlinecode{objekat.f()} $\sim$ \inlinecode{f(\&objekat)}
     \item Konstanti pokazivač na klasu čiji je metod član\\
    Klasa \inlinecode{X}, \inlinecode{this} $\rightarrow$ \inlinecode{X* const}
    \item Pristup se obavlja neposredno
    \item Primeri korišćenja
    \begin{enumerate}
        \item Tekući objekat vratiti kao rezultat metoda
        \item Adresa objekta je potrebna kao argument
        \item Tekući objekat ubaciti u listu
    \end{enumerate}
    \begin{lstlisting}
// Definicija metoda zbir(Kompleksni) klse Kompleksni
Kompleksni Kompleksni::zbir(Kompleksni C){
    Kompleksni t = *this; // u t se kopira tekuci objekat
    t.real+=c.real;
    t.imag+=c.imag;
    return t;
}
//...
int main(){
    Kompleksni c, c1,c2;
    //...
    c=c1.zbir(c2);
}
    \end{lstlisting}
\end{itemize}
\item Inspektori i mutatori
\begin{itemize}
    \item \textbf{Inspektor} ili selektor $\rightarrow$ ne menja stanje objekta
    \item \textbf{Mutator} ili modifikator $\rightarrow$ menja stanje objekta
    \item Dobra praksa da se kaže koji tip od ova dve je metod
    \item \inlinecode{const} iza liste parametara $\rightarrow$ inspektor
    \item Postoji konstantan metod, ali je to druga stvar
\end{itemize}

\item Definisanje inspektora\\
\inlinecode{<tip> ime(parametri) const \{definicija\}}
\begin{itemize}
    \item Notaciona pogodnost
    \item Prevodilac nema načina da osigura da inspektor ne menja atribute\\ Eksplicitna konverzija može da probiju konrolu konstantnosti
    \item U inspektoru \inlinecode{this} je \inlinecode{const X* const} 
    \item Nije moguće menjati objekat pomoću \inlinecode{this}
    \item Za nepromenljive objekte nije dozvoljeno pozivati metod koji nije inspektor
    \begin{lstlisting}
class X {
public:
    int citaj () const { return i; }
    int pisi (int j=0) { int t=i; i=j; return t; }
private:
    int i;
};
X x; const X cx;
x.citaj(); // OK - inspektor promenljivog objekta
x.pisi(); // OK - mutator promenljivog objekta
cx.citaj(); // OK - inspektor nepromenljivog objekta
cx.pisi(); // ERROR - mutator nepromenljivog objekta
    \end{lstlisting}
\end{itemize}
\newpage
\item Nepostojani metodi (\inlinecode{volatile})
\begin{itemize}
    \item Suprotnost konstantnog metoda
    \item Veza sa konkurentnim programiranjem
    \item Neki drugi \textit{thread} može u svakom trenutku da promeni stanje objekta
    \item Prevodilac ne izvršava optimizaciju
    \item \inlinecode{volatile} može da se poziva za nepostojane i promenljive objekte
    \item \inlinecode{const volatile} - za sve vrste objekata
    \begin{lstlisting}
class X {
public:
    X(){ kraj=false; }
    int f() volatile { // da nije volatile, moguca optimizacija:
    while(!kraj){/*...*/} // if (!kraj) while() {/*...*/}
    } // u telu (...) se ne menja kraj
    void zavrseno(){ kraj=true; }
private:
    bool kraj;
    \end{lstlisting}
\end{itemize}

\item Modifikatori metoda \inlinecode{\&} i \inlinecode{\&\&}
\begin{itemize}
    \item Bez modifikatora \inlinecode{\&} i \inlinecode{\&\&} metod se može primeniti na \inlinecode{lvalue} i \inlinecode{rvalue}
    \item Modifikator \inlinecode{\&} - tekući objekat može biti samo \inlinecode{lvalue}
    \item Modifikator \inlinecode{\&\&} - tekući objekat može biti samo \inlinecode{rvalue}
    \item \boxedimportant[BITNO]{ Mogu da postoje metodi čiji se potpisi razlikuju samo po ovom modifikatoru}
    \begin{lstlisting}
class U {
public:
    int f() & {return 1;}
    int f() const & {return 2;}
    int f() && {return 3;}
};
U u1; const U u2=u1;
int i = u1.f(); int j = u2.f(); int k = U().f();
    \end{lstlisting}
\end{itemize}

\item Pojam konstruktora
\begin{itemize}
    \item Specifična funkcija klase koju definiše početno stanje objekta
    \item Isto ime kao klasa
    \item Nema \inlinecode{return} tip, čak ni \inlinecode{void}
    \item Proizvoljan broj proizvoljnih tipova parametara
    \begin{enumerate}
        \item Ne sme biti tip klase koju definiše ako je jedini parametar ili ako svi ostali imaju podrazumevanu vrednost
        \item Dozboljen tip pokazivača na \inlinecode{lvalue} i \inlinecode{rvalue} date klase
    \end{enumerate}
    \item Implicitno se poziva prilikom kreiranja
    \item Pristup članovima objekta kao i bilo koji drugi metod
    \item Može biti preklopljen $\backslash$ \textit{overloaded}
\end{itemize}
\item Podrazumevani konstruktor
\begin{itemize}
    \item Može se pozvati bez stvarnih argumenata - nema parametre ili su svi podrazumevani
    \item Ugrađeni podrazumevani konstruktor je bez parametara i ima prazno telo
    \item Ugrađeni konstruktor postoji smao ako klasa nije definisala nijedan drugi konstruktor
    \item Definisanje nekog konstruktora se suspenduje ugrađeni\\
    Restauracija ugrađenog konstruktora - deklaracija iza koje sledi \inlinecode{= default}
    \item Kad se kreira niz objekata poziva se podrazumevani konstruktor po rastućem redosledu indeksa
\end{itemize}
\newpage
\item Pozivanje konstruktora
\begin{itemize}
    \item Stvaranje bilo kakvog objekta
\end{itemize}
\begin{enumerate}
    \item Definicija statičkog objekta
    \item Definicija automatskog objekta
    \item Dinamički objekat kreiran operatorom \inlinecode{new}
    \item Kad se stvarni argument klasnog tipa prenosi u formalni
    \item Kada se kreira privremeni objekat pri povratku iz funkcije
\end{enumerate}
\item Argumenti konstruktora
\begin{itemize}
    \item Pri stvaranju objekta moguće je navesti inicijalizator iza imena
    \item Inicijalizator sadrži listu argumenata konstruktora u zagradama
    \begin{enumerate}
        \item \inlinecode{()} ili \inlinecode{\{\}}
        \item Ako \inlinecode{\{\}} $\rightarrow$ može se pisati i \inlinecode{= \{...\}}
        \item Nisu dozboljene prazne zagrade \inlinecode{()}\\
        Deklaracija funkcije
    \end{enumerate}
    \item Moguća notacija \inlinecode{<objekat>  = <vrednost>}
    \item Poziva se onaj konstruktor koji se najbolje salže po potpisu
    \item Može da ima podrazumevane vrednosti
    
    \begin{multicols}{2}
    \begin{lstlisting}
class X {
    char a; int b;
public:
    X ();
    X (char, int=0);
    X (const char*);
    X(X); // ERROR
    X(X*);
    X(X&);
    X(X&&);
};
X f () {
    X x1; // X()
    X x2{}; // X()
    X x3={};// X()
    X x(); // dekl. f-je
    return x1;
}
\end{lstlisting}
\columnbreak
\begin{lstlisting}
void g () {
    char c='a';
    const char *p="Ne volim OOP";
    
    X x1(c); // X(char,int)
    X x2=c;
    X x3(c,10);
    X x4{c,20};
    X x5={c,30};
    X x6(p); // X(char*)
    X x7(x1); // X(X&)
    X x8{x1};
    X x9={x1};
    X x10=f(); // X(X&&)
    X* p1=new X;// X()
    X* p2=new X(); // X(char,int)
    X* p4=new X{c,10};
}
    
    \end{lstlisting}
    \end{multicols}
\end{itemize}
\newpage
\item Konstrukcija članova
\begin{itemize}
    \item Pre izvršavanja tela konstruktora
    \begin{enumerate}
        \item Inicijalizuju se prosti tipovi
        \item Pozivaju se konstruktori za klasne tipove
    \end{enumerate}
    \item Inicijalizatori mogu da se navedu u zaglavlju definicije (NE deklaracije) konstruktora, iza znaka \inlinecode:
    \item \boxedimportant[]{Ako atributi ima inicijalizatoru telu klase i u definiciji konstruktora $\rightarrow$ primenjuje se inicijalizator iz definicije konstruktora}
    \item \boxedimportant[BITNO]{Inicijalizacija atributa - \textbf{redosled navođenja u definiciji klase}
    \begin{itemize}
        \item[-] Bez obzira da li su primitivni ili klasni tipovi
        \item[-] Bez obzira na redosled u listi inicijalizatora
    \end{itemize}}\\\\
    \inlinecode{class X \{\\
    private:}\\
    \hspace*{0.5cm}
    \inlinecode{int i = 0; \\
    \}
    }
    \item Do C++11 nije bila dozvoljena inicijalizacija atributa u definiciji klase
    \item Inicijalizacija je različita od operacije dodele koja se može vršiti jedino unutar tela konstruktora
    \item Inicijalizacija je neophodna
    \begin{enumerate}
        \item Kada ne postoji podrazumevani konstruktor klase atributa
        \item Kada je atribut nepromenljiv
        \item Kada je atribut referenca
    \end{enumerate}
    \begin{lstlisting}
class YY { public: YY (int j) {...} };
class XX {
    YY y; int i=0;
public:
    XX (int);
};
XX::XX (int k) : y(k+1), i(k-1) {...} // y=k+1, i=k-1
    \end{lstlisting}
    \begin{lstlisting}
// Primer konstrukcija dva objekta od kojih jedan sadrzi drugi
class Kontejner {
public:
    Kontejner () : deo(this) {...}
private:
    Deo deo;
};
class Deo{
public:
    Deo(Kontejner* kontejner):mojKontejner(kontejner) {...}
private:
    Kontejner* mojKontejner;
};
    \end{lstlisting}
    \end{itemize}
\begin{multicols}{2}
\item Delegirajući konstruktor
\begin{itemize}
    \item U listi inicijalizatora definicije delegiruajućeg konstruktora može da se navede poziv drugog konstruktora
    \item Pre izvršenja tela delegirajućeg konstruktora, izvršava se ciljni konstruktor
\end{itemize}
\columnbreak
\begin{lstlisting}
class T {
    T(int i){}
    T():T(1){} // delegirajuci: T(), ciljni: T(int)
    T(char c): T(0.5){} // ERROR - rekurzija
    T(double d): T('a'){}   
}
\end{lstlisting}
\end{multicols}
\begin{itemize}
     \item Kad se navodi ciljni konstruktor, navodi se samo on
    \item Ako dolazi do neposrednog ili posrednog delegiranja $\rightarrow$ greška\\
    Prevodilac ne otkriva ovakav tip greške
\end{itemize}
\item Eksplicitni poziv konstruktora
\begin{itemize}
    \item Ovakav poziv kreira primvremeni objekat klase pozivom odgovarajućeg konstruktora
    \item Isto se dešava ako se u inicijalizatoru objekta eksplicitno navede poziv konstruktora\\
    \inlinecode{Kompleksni c = Kompleksni(0.1, 5);}\\
    Privremeni objekat se kopira u \inlinecode c - zavisi od prevodioca
\end{itemize}
\item Konstruktor kopije
\begin{itemize}
    \item Kopirajući konstruktor
    \item Pri inicijalizaciji objekta O1 drugim objektom O2 iste klase poziva se konstruktor kopije
    \item Ugrađeni, implicitno definisani, konstruktor kopije
    \begin{enumerate}
        \item Vrši inicijalizaicju članova O1 članovima O2 (pravi \textbf{plitku kopiju} - \textit{shallow copy})
        \item Primitivni atributi se prosto kopiraju - uključujući i pokazivače
        \item Za klasne atribute se pozivaju njihovi konstruktori kopije
    \end{enumerate}
    \item Ugrađeni konstruktor kopije se briše ili suspenduje
    \begin{enumerate}
        \item Eksplicitno\\
        \inlinecode{X(const X\&) = delete}
        \item Implicitno - pisanjem premeštajućeg konstruktora ili premeštajućeg operatora deodele\\
        Restauriranje konstruktora kopije \inlinecode{X(const X\&) = default}
    \end{enumerate}
    \item Problem pokazivača $\rightarrow$ pravimo \textbf{duboku} kopiju - \textit{deep copy}
    \item Parametri konstruktora kopije su \inlinecode{X\&} ili \inlinecode{const X\&}
    \item Ostali eventualni parametri moraju biti podrazumevane vrednosti
\end{itemize}
\item Pozivanje konstruktora kopije
\begin{itemize}
    \item Poziva se jednim stvarnim argumentom
    \item Konstruktor kopij se poziva kada se objekat inicializuje objektom iste klase i to
    \begin{enumerate}
        \item Prilikom stvaranja trajnog, automatskog, dinamičkog ili privremenog objekta
        \item Prilikom prenosa argumenata po vrednosti u funkciju (stvara se automatski objekat)
        \item Prilikom vraćanja vrednosti iz funkcije (stvara se privremeni objekat
    \end{enumerate}
    \item Prevodilac sme da preskoči poziv konstruktora kopije zbog optimizacije
    \begin{itemize}
        \item[-] Ako se stvarani objekat inicijalizuje privremenim objektom iste klase
        \item[-] Izostaju bočno efekti koje programer očekuje
        \item[-] Čak i tada mora postojati konstruktor kopije ili premeštajući konstruktor
    \end{itemize}
    \begin{lstlisting}
class XX {
public:
    XX (int);
    XX (const XX&); // konstruktor kopije
    //...
};
XX f(XX x1) {
    XX x2=x1; // poziv konst. kopije XX(XX&) za x2
    return x2; // poziv konst. kopije za privremeni
} // objekat u koji se smesta rezultat
void g() {
    XX xa=3, xb=1;
    xa=f(xb); // poziv konst. kopije samo za parametar x1,
// a u xa se samo prepisuje
// privremeni objekat rezultata, ili se
} // poziva XX::operator= ako je definisan
    \end{lstlisting}
\end{itemize}
\newpage
\item Premeštajući konstruktor
\begin{itemize}
    \item Konstruktor koji se poziva za konstrukciju objekta istog tipa, pri čemu je izvorišni objekat na kraju životnog veka
    \item Izvorišni objekat je \textbf{nvrednost} (nestajuća vrednost) - \textit{xvalue (expiring value)}
    \item Izvorišni objekat ne mora da se sačuva
    \item Samo premestimo njegove dinamičke delove u odredišni objekat
    \item Nema kopiranja dinamičkih delova
    \item Posledica $\rightarrow$ premeštajući konstruktor je efikasniji od kopirajućeg
    \item Modifikovati izvorišni objekat da njegova destrukcija ne povuče razaranje premeštenih delova
    \item Postoji ugrađeni, implicitno definisani, premeštajući konstruktor, ali ona ima problem - ne briše originalne pokazivače u izvorišnom objektu
    \item Ugrađeni premeštajući konstruktor se briše ako se eksplicitno definiše bar jedan od navedenih: \marginnote{Nisam 100\% siguran za ovo BAR}
    \begin{enumerate}
        \item Premeštajući konstruktor
        \item Kopirajući konstruktor
        \item Destruktor
        \item Operator dodele
    \end{enumerate}
    
\end{itemize}

\item Pozivanje premeštajućeg konstruktora
\begin{itemize}
    \item Paramater je \inlinecode{X\&\&}, ostali su podrazumevani parametri \marginnote{BEZ CONST}
    \item Prevodilac poziva premeštajući konstruktor
    \begin{enumerate}
        \item Ako izvorišni objekat nestaje
        \item Ako u klasi postoji premeštajući konstruktor
    \end{enumerate}
    \item Ako u klasi ne postoji premeštajući
    \begin{enumerate}
        \item Poziva se kopirajući konstruktor
        \item Semantika je ista
        \item Promena je samo u efikasnosti
    \end{enumerate}
    \begin{lstlisting}
class Niz {
    double* a; int n;
public: ... Niz( Niz&& niz ){ a=niz.a; niz.a=nullptr; n=niz.n; }
} ...
Niz f(Niz niz){ return niz; }
    \end{lstlisting}
\end{itemize}
\item Konverzioni konstruktor
\begin{itemize}
    \item Konverzija između tipova od kojih je bar jedan klasa
    \item Odredišni tip mora biti klasa\\
    \inlinecode{X::X(T\&) X:: X(T)} $\rightarrow$ konverzija tipa T u X
    \item Korisničke konverzije se primenjuju automatski ako je jednoznačan izbor konverzije, izuzev u slučaju \inlinecode{explicit} konstruktora
    \item Konverzija mora biti posredna\\
    \inlinecode{U::U(T\&), V::V(U\&) } $\rightarrow$ \inlinecode{V(U(t))} eksplicitno
    \item Nije moguće konvertovati u primitivni tip
    \item Konverzija argumenata i rezultat funkcije
    \begin{enumerate}
        \item Pri pozivu funkcije
        \begin{itemize}
            \item[-] Inicijalizuju se parametri stvarnim argumentima uz eventualnu konverziju tipa
            \item[-] Parametri se ponašaju kao automatski lokalni objekti pozvane funkcije
            \item[-] Ovi objekti se konstruišu pozivom odgovarajućih konstruktora
        \end{itemize}
        \item Pri povratku iz funkcije
        \begin{itemize}
            \item[-] Konstruiše se privremeni objekat koji prihvata vrednost \inlinecode{return} izraza na mestu poziva
        \end{itemize}
    \end{enumerate}
    \newpage
    \begin{lstlisting}
//Konverzioni konstruktor - PRIMER
class T {
public:
    T(int i); // Konstruktor
};
T f (T k) {
    //...
    return 2; // Poziva se konstruktor T(2)
}
int main () {
    T k(0);
    k=f(1); // Poziva se konstruktor T(1)
    //...
}
    \end{lstlisting}
\end{itemize}
\item Destruktor
\begin{itemize}
    \item Specifična funkcija članica koja uništava objekat
    \item Nosi isto ime kao klasa, uz $\sim$ ispred imena
    \item Nema tip rezltata i ne može imati parametre $\rightarrow$ najviše 1 po klasi
    \item Destruktor se piše kada treba osloboditi memoriju i ostale resurse
    \item Česta potreba $\rightarrow$ klasa sadrži članove koji su pokazivači ili reference na druge objekte\\
    Dobra praksa tad $\rightarrow$ metod za uništavanje delova, pozvan iz konstruktora
    \item Ponašanje kao i drugim metodima
\end{itemize}


\item Pozivanje destruktora
\begin{itemize}
    \item Implicitno se poziva na kraju životnog veka objekta
    \item Pri uništavanju dinamičkog objekte koristeći \inlinecode{delete}
    \item Pri uništavanju dinamičkog niza - u smeru opadajućih indeksa
    \item Redosled je uvek obrnut od konstruktora
    \item Eksplicitno pozivanje\\
    \inlinecode{X.$\sim$X(), px->$\sim$X(), this->$\sim$X()}
    \begin{itemize}
        \item[-] Ne preporučuje se, objekat nastavi da živi i posle ovoga
    \end{itemize}
    \item Posle izvršenja automatskog destruktora se oslobađa zauzeta memorija
\end{itemize}
\item Statički (zajednički) atributi
\begin{itemize}
    \item Pri stvaranju objekta klase $\rightarrow$ poseban komplet nestatičkih atributa
    \item Ključna reč - \inlinecode{static}
    \item Jedan primerak za celu klasu, svi objekti ga dele\\
    \inlinecode{static <tip> ime;}
\end{itemize}
\item Definisanje statičkog atributa
\begin{itemize}
    \item U klasi se samo deklariše
    \item Mora da se definiša na globalnom nivou
    \item Svi oblici inicijalizatora \checkmark{}
    \item Inicijalizacija
    \begin{enumerate}
        \item Pre prvog pristupa njemu
        \item Pre stvaranja objekta date klase
    \end{enumerate}
    \item Obraćanje \inlinecode{int <klasa>::X=5; // bez static}
    \item Ako se navede inicijalizator $\rightarrow$ 0
    \item \boxedimportant[ČUDNO]{Imenovana \textbf{celobrojna} konstanta može se definisati i u definiciji klase}
    \marginnote{Ima veze sa constexpr?}
   
\end{itemize}
\newpage
\item Statički i globalni podaci
\begin{itemize}
    \item Sličnosti
    \begin{enumerate}
        \item Trajni podaci $\rightarrow$ sličan životni vek
        \item Definicija na globalnom nivou
    \end{enumerate}
    \item Razlike
    \begin{enumerate}
        \item Statički atributi pripadaju klasi
        \item Doseg imena statičkog atributa je klasa
        \item Statičkim atributima je moguće ograničiti pristup
    \end{enumerate}
    \item Statički atribut ima sva svojstva globalnog statičkog podatka osim dosega imena i kontrole pristupa
    \item Smanjuje se potreba za globalnim objektima
\end{itemize}


\item Statički (zajednički) metodi
\begin{itemize}
    \item Funkcija klase, a ne svakog posebnog objekta
    \item Zajednički za sve objekte
    \item Primena
    \begin{enumerate}
        \item Opšte usluge
        \item Obrada statičkih atributa
    \end{enumerate}
    \item Deklarišu se dodavanjem \inlinecode{static} ispred deklaracije
    \item Svojstva globalnih funkcija osim dosega i kontrole pristupa
    \item Nemaju \inlinecode{this}
    \begin{enumerate}
        \item Ne mogu pristupati nestatičkim članovima direktnim imenovanjem
        \item Modifikatori \inlinecode{const} i ostali nemaju smisla
    \end{enumerate}
    \item Mogu pristupati nestatičkim članovima konkretnih objekata
    \begin{enumerate}
        \item Pristup preko parametra
        \item Pristup lokalnom objekta
        \item Pristup globalnom objektu
    \end{enumerate}
    \item Direktan pristup statičkim članovima\\
    \inlinecode{<klasa>::<ime\_funkcije>(argumenti);}
    \item Može se pozvati za konkretan objekat, ali izbegavati\\
    Levi operand tada samo nađe tip bez ikakvog izračunavanja
    \item Mogu se pozivati i pre stvaranja objekta klase
    \item Uslužna klasa $\rightarrow$ sve statički metodi, obrisanog ugrađenog konstruktora - kao biblioteka
\begin{center}
    \begin{adjustwidth}{-4cm}{-2.5cm}

    \begin{multicols}{2}
    \begin{lstlisting}
class X {
    static int x; // staticki atribut
    int y;
public:
    static int f(X); // staticki metod (deklaracija)
    int g();
};
int X::x=5; // definicija statickog atributa
int X::f(X x1){ // definicija statickog metoda
    int i=x; // pristup statickom atributu X::x
    int j=y;  // ERROR - X::y nije staticki
    int k=x1.y; // ovo moze;
    (x1++).x; // x1++ (ako je definisan post inkrement operator) se ne izracunava po Tartalji 
    return x1.x;  // i ovo moze, ali nije preporucljivo
} // izraz "x1" se ne izracunava 
    \end{lstlisting}
    \columnbreak
    \begin{lstlisting}

int X::g () {
    int i=x; // nestaticki metod moze da koristi
    int j=y; // i staticke i nestaticke atribute
    return j; // y je ovde this->y;
}
int main () {
    X xx;
    int p=X::f(xx); 
    // X::f moze neposredno, bez objekta;
    int q=X::g(); 
    // ERROR - za X::g mora konkretan objekat
    xx.g(); // ovako moze;
    p=xx.f(xx); // i ovako moze, ali nije preporucljivo
}

 
  
   
    
     
     
     
    \end{lstlisting}
    \end{multicols}
\end{adjustwidth}
\end{center}
 \newpage
    \begin{lstlisting}
// Zadatak koji se pojavio na kolokvijumu
class X {
public: static X* kreiraj () { return new X; }
private: X(); // Konstruktor je privatan
};
int main() {
    X x; // ERROR
    X* px=X::kreiraj(); // OK
}
 \end{lstlisting}

\end{itemize}
\item Prijatelji klasa
\begin{itemize}
    \item Kad je potrebno da klasa ima povlašćene korisnike koji mogu da pristupaju njenim privatnim članovima
    \item Povlašćene mogu biti
    \begin{enumerate}
        \item Funkcije
        \item Cele klase
    \end{enumerate}
    \item Nazivamo ih \textbf{prijateljima} - \textit{friends}
    \item Prijateljstvo, kao relacija između klasa
    \begin{enumerate}
        \item Ne nasleđuje se
        \item Nije simetrično \frownie
        \item Nije tranzitivno
    \end{enumerate}
    \item Reguliše isključivo pravo pristupa, a ne i oblast važenja i vidljivost identifikatora
\end{itemize}
\item Prijateljski funkcije
\begin{itemize}
    \item Nisu članice klasa ali imaju pristup privatnim članovima
    \item Mogu biti metode druge klase ili globalne funkcije
    \item Funkcija je prijateljska ako se u definiciji klase navede njena deklaracija ili definicija sa modifikatorom \inlinecode{friend}
    \item Klasa mora eksplicitno da naglasi prijateljstvo
    \item Ako u definiciji klase pišemo prijateljsku funkciju
    \begin{enumerate}
        \item I dalje nije članica klase iako je definišemo unutar nje
        \item Podrazumeva se da je \inlinecode{inline}
        \item Funkcija nema klasni doseg već doseg identifikatora klase
    \end{enumerate}
    \item Nevažno je pravo pristupa za \inlinecode{friend} funkciju
    \item Nema \inlinecode{this}
    \item Funkcija može biti prijatelj većem broju klasa istovremeno
    \begin{lstlisting}
class X {
    friend void g(int, X&); // prijateljska globalna funkcija
    friend void Y::h(); // prijateljski metod druge klase
    friend int o(X x){return x.i;}// definicija globalne f-je
    friend int p(){return i;} // ERROR - nema this
    int i;
public:
    void f(int ip) {i=ip;}
};
void g (int k, X &x) { x.i=k; }
int main () {
    X x; int j;
    x.f(5); // P preko metoda
    g(6,x); // Postavljanje preko prijateljske funkcije
    j=o(x); // Citanje preko prijateljske funkcije
}
    \end{lstlisting}
\end{itemize}
 \newpage
\item Prijateljske funkcije i metodi
\begin{itemize}
    \item Nekad je bolja prijateljska funkcija od metoda
    \item Metod mora da se pozove za objekat date klase, dok globalnoj funkciji možemo dostaviti i oblik drugog tipa\\
    Nemoguća konverzija skrivenog argumenta u metodu
    \item Pristup privatnim članovima više klasa - simetrično rešenje
    \item Nekad je jenotacija pogodnija\\
    \inlinecode{max(a,b)} ili \inlinecode{a.max(b)}
    \item Kad se preklapaju operator, često je jednostavnije definisati globalne operatorske funkcije nego metode
\end{itemize}
\item Prijateljske klase
\begin{itemize}
    \item Ako su svi metodi klase Y prijateljske funkcije klase X, onda je Y prijateljska klasa (\textit{friend class}) klasi X\\\\
    \inlinecode{class X \{}\\
    \hspace*{1cm}\inlinecode{friend Y; // Ako je klasa Y definisana ili deklarisana}\\
    \hspace*{1cm}\inlinecode{friend class Z; // Ako Z nije ni definisana ni deklarisana}\\
    \inlinecode{\};}
    \item Svi metodi klase Y pristupaju privatnim članovima klase X
    \item Prijateljske klase se često koriste kad neke dve klase imaju tesnu vezu
\end{itemize}
\item Ugnježdene klase
\begin{itemize}
    \item Klase mogu da se deklarišu ili definišu unutar definicije druge klase
    \item Koristi se kada neki tip semantički pripada samo datoj klasi
    \item Povećava čitljivost i smanjuje potrebu za globalnim tipovima
    \item Unutar definicije klase se mogu navesti i definicije nabrajanja \inlinecode{enum} i tipova \inlinecode{typedef}
    \item Ugnježdena klasa se nalaziu dosegu imena okružujuće klase (izvan nje pristup samo sa \inlinecode{::})
    \item Iz okružujuće klase u ugnježdenu \inlinecode{., ->, ::}
    \item Doseg imena okružujuće klase O se proteže na ugnježdenu klasu U\\
    Pristup iz U do članova O samo sa \inlinecode{., ->}
    \item U ugnježdenoj klasi mogu direktno da se koriste identifikatori
    \begin{enumerate}
        \item \boxedimportant[]{Tipova iz okružujuće klase $\longleftarrow$ Samo od konkretnog objekta}
        \item Konstanti tipa nabrajanja okružujuće klase
        \item Statički članovi okružujuće klase
    \end{enumerate}
    \item \boxedimportant[Zar nije obrnuto?]{Ovo važi ako ime nije sakriveno imenom člana \textbf{ugnježdene} klase}\\\\
    \inlinecode{<id\_okružujuće>::<id\_ugnježdene>::<id\_statičkog>}
    \item Ugnježdena klasa je implicitno prijatelj okružujuće
    \item Okružujuća klasa nije prijatelj ugnježdene \frownie $\longleftarrow$ ugnježdena klasa
    \begin{lstlisting}
int x,y;
class Spoljna {
public:
    int x; static int z;
    class Unutrasnja {
        void f(int i, Spoljna *ps) {
            x=i; // ERROR - nepoznat objekat klase Spoljna
            Spoljna::x=i; // ERROR - isti uzrok
            z=i; // pristup statickom clanu Spoljna
            ::x=i; // pristup globalnom x;
            y=i; // pristup globalnom y;
            ps->x=i; // pristup Spoljna::x objekta *ps; 
        }
    };
};
Unutrasnja u; // ERROR
Spoljna::Unutrasnja u; // OK
    \end{lstlisting}
\end{itemize}

\item Strukture
\begin{itemize}
    \item Struktura je klasa kod koje su svi članovi podrazumevano javni\\
    Može se menjati eksplicitnim korišćenjem \inlinecode{public:} i \inlinecode{private:}
    \item C++ struktura može imati i metode
    \item Strukture se koriste za definisanje struktuiranih podataka koje ne predstavljaju apstrakciju i generalno nemaju značajnijih operacija
    \item Tipično imaju samo konstruktor, uz eventualni destruktor
\end{itemize}
\item Lokalne klase 
\begin{itemize}
    \item Definišu se unutar funkcija
    \item Identifikator ima doseg od deklaracije do kraja bloka u kom je deklarisan
    \item Unutar klase dozvoljeno je korišćenje iz okružujućeg dosega
    \begin{enumerate}
        \item Identifikatora tipova
        \item Konstanti tipa nabrajanja
        \item Trajnih podataka (statičkih atributa, statičkih lokalnih i globalnih)
        \item Spoljašnjih (\inlinecode{extern}) podataka i funkcija
    \end{enumerate}
    \item Metodi lokalne klase moraju da se definišu unutar definicije klasa
    \item Lokalna klasa ne može da ima statičke atribute, dok može imati statičke metode
    \begin{lstlisting}
int x;
void f() {
    static int s;
    int x;
    extern int g();
    class Lokalna {
    public:
        int h (){ return x; } // ERROR - x je automatska prom.
        int j (){ return s; } // OK: s je staticka promenljiva
        int k (){ return ::x; } // OK: x je globalna promenljiva
        int l (){ return g(); } // OK: g() je spoljasnja funkcija
    };
}
Lokalna *p = 0; // ERROR - nije u dosegu
    \end{lstlisting}
\end{itemize}
\item Pokazivači na članove klase
\begin{itemize}
    \item Dodelom vrednosti pokazivaču na članove klase označi se nei član klase\\
    Kao pokazivačka aritmetika indeksa u nizu
    \item Deklaracija\\
    \inlinecode{<tip\_člana><klasa>::*<identifikator>}
    \item Formiranje adrese\\
    \inlinecode{<identifikator> = \&<klasa>::<član>}
    \item Pristup\\
    \inlinecode{<objekat>.*<identifikator>}\\
    \inlinecode{<pokazivač\_na\_objekat>->*<identifikator>}
    \item \inlinecode{.*} i \inlinecode{->*} imaju prioritet 14 i asocijativnost sleva na desno
    \begin{lstlisting}
class Alfa {... public: int a, b; };

int Alfa::*pc;// pc je pokazivac na int clanove klase Alfa
Alfa alfa,*beta;
beta=&alfa;

pc=&Alfa::a;// pc pokazuje na clanove a objekata klase Alfa
alfa.*pc = 1; // alfa.a=1;
beta->*pc = 1; // beta->a=1;

pc=&Alfa::b;// pc pokazuje na clanove b objekata klase Alfa
alfa.*pc = 2; // alfa.b=2;
beta->*pc = 2; // beta->b=2;
    \end{lstlisting}
\end{itemize}
\item UML
\begin{itemize}
    \item Grafička notacija za modeliranje\\\\
    \begin{figure}[h]
        \begin{tikzpicture}
    \begin{umlpackage}{UML - OSNOVE}
    \begin{umlpackage}[y=-1]{KLASA}
    \umlclass[]{TackaRavni}{
    x : double\\y : double
    }{
    rastojanje(T : Tacka) : double
    }
    \end{umlpackage}
    \begin{umlpackage}[x=-1.4, y=-4]{OBJEKAT}
    
    \begin{umlseqdiag}
    \umlobject[class=TackaRavni]{T}
    \end{umlseqdiag}
    \end{umlpackage}
    \begin{umlpackage}[x=7, y=0.8]{RELACIJE}
    \begin{umlpackage}{ASOCIJACIJA}
    \umlclass[]{Fakultet}{}{}
    \umlclass[x=4]{Osoba}{}{}
    \end{umlpackage}
    \begin{umlpackage}[x=-0.25,y=-2.5]{ZAVISNOST}
    \umlclass[]{Krug}{}{}
    \umlclass[x=4.35]{Boja}{}{}
    \end{umlpackage}
    \begin{umlpackage}[y=-5]{AGREGACIJA}
    \umlclass[]{Kvadrat}{}{}
    \umlclass[x=4]{Tacka}{}{}
    \end{umlpackage}
    \begin{umlpackage}[x=0.2, y=-7.5]{KOMPOZICIJA}
    \umlclass[]{Automobil}{}{}
    \umlclass[x=4]{Tocak}{}{}
    \end{umlpackage}
    \end{umlpackage}
    \end{umlpackage}
    \umlassoc[geometry=-|-, arg1=1, pos1=0.3, arg2=1..N,pos2=1, align2=left]{Fakultet}{Osoba}
    \umlimport[geometry=|-, name=import]{Krug}{Boja}
    \umlaggreg[arg=centar , mult1=1..*, pos1= 0.2, mult2=1, pos2=0.8]{Kvadrat}{Tacka}
    \umlunicompo[geometry=-|, mult1=1, pos1=0.2, mult2=4, pos2=0.6]{Automobil}{Tocak}
    \end{tikzpicture}
    \end{figure}
    
\end{itemize}
\end{xitemize}
\begin{center}
    SI KOLOKVIJUM 1
    \hzline
\end{center}
\section{Preklapanje operatora}
\begin{xitemize}
\item Pojam preklapanja operatora
\begin{itemize}
    \item Drugi naziv - \textbf{preopterećivanje operatora} - \textit{operator overloading}
    \item Nova značenja operatora za korisničke tipove
    \item Sličan princip kao kod preklapanja funkcija
    \item Operatorske funkcije nose ime \inlinecode{operator@}, gde je \inlinecode@ neki operator ugrađen u jezik
    \item Izraz \inlinecode{T1 @ T2} može biti tumačen kao
    \begin{enumerate}
        \item \inlinecode{operator@(T1, T2);} - \inlinecode{friend} funkcija
        \item \inlinecode{T1.operator@(T2);} - operatorski metod
    \end{enumerate}
    \begin{lstlisting}
class Kompleksni {
private:
    double real, imag;
public:
    Kompleksni (double, double); // Konstruktor
        // Operator + u obliku globalne prijateljske funkcije
        friend Kompleksni operator+(Kompleksni, Kompleksni); 
        Kompleksni operator-(Kompleksni K){ // Klasni metod
        Kompleksni novi_broj;
        novi_broj.real = this->real - K.real;
        novi_broj.imag = this->imag - K.imag;
        return novi_broj;
    }
};
// Definicija konstruktora
Kompleksni::Kompleksni(double r=0.0, double i = 0.0) : real(r), imag(i) {} 
Kompleksni operator+ (Kompleksni K1, Kompleksni K2){
    Kompleksni novi_broj;
    novi_broj.real = this->real + K.real;
    novi_broj.imag = this->imag + K.imag;
    return novi_broj;
}
/*...*/
Kompleksni K1(1.0, 1.0), K2(2.0, 2.0), K3, K4;
K3 = K1+K2; // operator+(K1, K2);
K4 = K3-K2; // K3.operator-(K2);
    \end{lstlisting}
\end{itemize}
\item Ograničenja preklapanja operatora
\begin{itemize}
    \item Sledeći operatori se \textbf{ne} mogu preklopiti:\\
    \inlinecode{., .*, ::, ?:, sizeof, alignof, typeid, throw}
    \item Ne može se menjati operator nekog primitivnog tipa
    \item Ne može mo praviti nove operatore, kao ni menjati osobine postojećih $\begin{cases}
        \textbf{Prioritet}\\
        \textbf{n-arnost}\\
        \textbf{Asocijativnost}
        \end{cases}$
    \item Neki operatori imaju specijalna ograničenja\\
    \inlinecode{=}, postfiksni \inlinecode{++} i \inlinecode{ --, [], ->, (tip), new, delete}
\end{itemize}
\item Pravila preklapanja operatora
\begin{itemize}
    \item Operatori koji su definisani implicitno\\
    \inlinecode{=, \&, ., ,} (zapeta),  \underline{\inlinecode{*, ->, []}} $\longleftarrow$ Poslednja 3 rade normalno i kad su preklopljeni, samo se sad mogu \hspace*{4.85cm}primeniti i na obektu
    \item Vraćeni rezultat je proizvoljan
    \item Ako se simbol piše slovima (\inlinecode{new, delete}), onda stoji odvojeno od \inlinecode{operator}
    \item Operatorske funkcije ne mogu imati podrazumevane vrednosti
    \item Operatorski metodi ne mogu biti statički, osim \inlinecode{new} i \inlinecode{delete}
    \item Deo potpisa operatorskog metoda čine i modifikatori tekućeg objekta\\
    \inlinecode{const, volatile, \&, \&\&}
\end{itemize}
\item Bočni efekti i veze između operatora
\begin{itemize}
    \item Ne podrazumeva se bočni efekat kod operatora koji ga inače imaju\\
    \inlinecode{++, --, =, +=, -=, ...}
    \item Loša praksa
    $\begin{cases}
     \textbf{Može se preklopiti da nema bočnog efekta tamo gde obično postoji} \\
     \textbf{Može se napraviti bočni efekat tamo gde ga inače nema}
    \end{cases}$
    \item Veze koje postoje između primitivnih operatora nisu garantovane\\
    \inlinecode{a+=b} $\centernot\implies$ \inlinecode{a = a + b}
    \item Ovi operatori se moraju eksplicitno preklopiti
\end{itemize}
\item Preporuke kod preklapanja operatora
\begin{itemize}
    \item Preklopljeni operatori treba da imaju očekivana značenja
    \begin{enumerate}
        \item Ako standardni operator ima bočni efekat, i preklopljeni bi trebao da ga ima
        \item Ako standardni operator vraća \inlinecode{lvalue}, i preklopljeni bi trebao da ga vraća
    \end{enumerate}
    \item Kada se definišu operatori za klasu, treba težiti da njihov skup bude kompletan\\
    Ako imam definisane \inlinecode{+, =} trebalo bi da definišem i \inlinecode{+=}
\end{itemize}
\item Operatorski metodi/globalne prijateljske funkcije
\begin{itemize}
    \item Operatorske funkcije mogu biti
    \begin{enumerate}
        \item Metodi klase
        \item Globalne prijateljske funkcije
    \end{enumerate}
    \item Kod globalne funkcije, bar 1 parametar mora biti klasnog tipa\\
    \inlinecode{a.operator@(b)} $\longleftarrow$ Metod klase\\
    \inlinecode{operator@(a,b)} $\longleftarrow$ Globalna prijateljska funkcija
    \item Ne možemo imati oba
\end{itemize}
\item Ograničenja operatorskog metoda
\begin{itemize}
    \item Ako levi operand binarne operacije treba da bude standardnog tipa $\rightarrow$ moramo definisati globalnu funkciju
    \item Kod operatorskog metoda levi operand je uvek skriveni parametar, i uvek je tipa klase kojoj pripada \\
    Primer je operacija oduzimanja
    \item Opreatorski metod ne dozvoljava konverziju levog operanda
\end{itemize}
\item Unarni i binarni operatori
\begin{multicols}{2}
\begin{itemize}
    \item Unarni\\
    \inlinecode{tip operator@() // Metod}\\
    \inlinecode{tip operator@(X x) // Globalna funkcija}
    \columnbreak
    \item Binarni\\
    \inlinecode{tip operator@(X x\_desno) }\\
    \inlinecode{tip operator@(X x\_levo, X x\_desno)}
\end{itemize}
\end{multicols}

\item Inicijalizacija i dodela vrednosti
\begin{itemize}
    \item Inicijalizacija podrazumeva da objekat još ne postoji, dok dodela podrazumeva suprotno
    \item Inicijalizacija se vrši uvek kada se kreira objekat
    \item Inicijalizacija poziva konstruktor, a ne operator dodele
    \item Konstruktor se poziva čak iako je notacija za inicijalizaciju operator \inlinecode=
    \item Ako je izraz sa desne strane simbola \inlinecode=
    \begin{enumerate}
        \item Istog tipa kao objekat koji se kreira, poziva se ili konstruktor kopije, ili premeštajući konstruktor
        \item Različitog tipa u odnosu na objekat koji se kreira, poziva se konverzioni konstruktor
    \end{enumerate}
    \item U oba slučaja može biti pozvan konstruktor sa više paramteara, ako svi ostali parametri imaju podrazumevane vrednosti
    \item Dodela $\rightarrow$ Izvršavanje izraza sa operatorom dodele \inlinecode=
    \item Podrazumevano značenje je kopiranje objekta član po član
    \begin{enumerate}
        \item Primitivni tipovi $\rightarrow$ kopiranje vrednosti
        \item Klasni tipovi $\rightarrow$ poziva se operator dodele odgovarajuće klase
        \item Pokazivački tipovi $\rightarrow$ kopiraće se samo pokazivač, a ne i pokazivana vrednost/objekat. Ako treba kopirati i pokazani objekat mora se preklopiti operator odele (\textit{deep copy})
    \end{enumerate}
\end{itemize}
\item Preklapanje operatora dodele
\begin{itemize}
    \item Mora biti nestatički metod
    \item Ugrađena varijanta vriši plitko kopiranje (\textit{shallow copy})
    \item Ugrađena varijanta vraća \inlinecode{lvalue}, pa je preporuka da se rezultat vraća po referenci
    \item Najčešća optimizacija
    \begin{enumerate}
        \item Prvo se ispita da nije slučaj poziva \inlinecode{a = a}, jer tada ništa ne radimo (bitno je da se ovo uradi, jer može da dođe do slučajnog brisanja objekta)
        \item Uništavaju se delovi levog operanda (nije neophodno, pogotovo ako su iste veličine kao i delovi desnog operanda)
        \item Kopiraju se (ili premeštaju) delovi desnog operanda u levi
    \end{enumerate}
    \begin{lstlisting}
X& X::operator=(const X& x){
    if(&x != this) { // Proveravamo da li su isti objekat
    // Formiramo nove delove
    // Kopiramo sadrzaje iz x
    }
    return *this;
}
    \end{lstlisting}
\end{itemize}
\item Varijante operatora dodele
\begin{itemize}
    \item Kopirajuća i premeštajuća verzija
    \item Razlika samo u efikasnosti, semantički su isti
    \item Razlika u tipu parametra
    \begin{enumerate}
        \item \inlinecode{X\& X::operator=(const X\& x)} $\longleftarrow$ Kopirajući konstruktor
        \item \inlinecode{X\& X::operator=(X\&\& x)} $\longleftarrow$ Premeštajući konstruktor
    \end{enumerate}
    \item Obe verzije imaju ugrađene definicije koje rade plitku kopiju
    \item Ugrađena kopirajuća se briše ako se definiše\\
    \boxedimportant[ČUDNO]{
    \begin{enumerate}
        \item Premeštajući konstruktor
        \item Premeštajuća dodela
    \end{enumerate}
    }
    \item Ugrađena premeštajuća dodela se briše ako se definiše
    \begin{enumerate}
        \item Kopirajući konstruktor
        \item Premeštajući konstruktor
        \item Konstruktor
        \item Destruktor
        \item Kopirajuća dodela
    \end{enumerate}
    \item \boxedimportant[PREM.?]{Restauracija kopirajućeg sa \inlinecode{=default}}
    \item Ako u klasi ne postoji premeštajuća dodela, koristi se kopirajuća
\end{itemize}
\item Preporuke za operator dodele
\begin{itemize}
    \item Ako se za klasu pišu destruktor, konstruktor kopije ili operator dodele, sva je prilika da trea ispisati sve te funkcije
    \item Ako se za klasu piše operator dodele sva je prilika da treba napisati i kopirajuću i premeštajuću dodelu
    \item Implementacija
    \begin{itemize}
        \item[-] Napraviti privatne metode $\begin{cases}
        \inlinecode{kopiraj(x)}\\
        \inlinecode{premesti(x)}\\
        \inlinecode{brisi(x)}
        \end{cases}$
        \item[-] Ovi metodi se koriste na mnogo mesta, pa je zgodno napisati ih samo jednom
        \item[-] Alternativa - \textit{copy-and-swap} koja objedinjuje dva tipa operatora dodele\\
        Umesto po referenci, prosledi se kopija desnog operanda na stek, zatim se izvrši razmena objekata i destruktor obriše ostatke levog operanda kada skidamo objekta sa steka
    \end{itemize}
    \begin{lstlisting}
/*...*/
int main(){
    X x = X("OOP");        // X(const char*); Konverzioni konstruktor
      y = x,               // X(const X&); Konstruktor kopije
      z = X("me cini");    // X(const char*); X(const X&&); Premestajuci konstruktor
    x = y;                 // operator=(const X&); Kopirajuca dodela
    y = X("tuznim");       // X(const char*); operator=(const X&&); Premestajuca dodela
/* Paziti na optimizacije kompajlera. Nekad kompajler izvrsi nesto sto ne ocekujemo*/    
 
}
    \end{lstlisting}
\end{itemize}
\item Preklapanje operator \inlinecode{++} i \inlinecode{--}
\begin{itemize}
    \item Problem nastaje jer postoje i prefiksna i postfiksna verzija
    \begin{multicols}{2}
    \item Prefiksna\\
    \inlinecode{T\& operator@@()}\\
    \inlinecode{T\& operator@@(T\&)}
    \columnbreak
    \item Postfiksna\\
    \inlinecode{T operator@@(int)}\\
    \inlinecode{T operator@@(T\&, int)}
    \end{multicols}
    \item Za poziv postfiksne, parametar tipa int ima vrednost 0
    \item Može i \inlinecode{t.operator@@(k)} ili \inlinecode{operator@@(t, k)}, gde je k $\neq$ 0, ali je besmisleno
\end{itemize}
\item Preklapanje operatora \inlinecode{[]}
\begin{itemize}
    \item Mora biti nestatički metod, i ne može biti globalna funkcija
    \item Kod standardnog indeksiranja indeksni izraz mora biti celobrojnog tipa
    \item Kod preklopljenog indeksiranja indeksni izraz može biti proizvoljnog tipa\\
    \inlinecode{X[ind] = x.operator[](ind)}
    \item Preklapanje omogućava \inlinecode{o[i]}, gde je o objekat date klase
    \item Primer primene $\rightarrow$ kontejner za niz koji prati maksimalni i minimalni indeks i prati prekoračenja
    \item Dve varijante
    \begin{enumerate}
        \item \inlinecode{T\& operator[](ind) // Mozemo da menjamo objekat na ind}
        \item \inlinecode{const T\& operator[](ind) const // Mozemo samo da citamo objekat na ind}
    \end{enumerate}
    \item Preklopljeni operator \inlinecode{[]} nije indeksiranje, već koristi notaciju indeksiranja
    \item Deluje na objekat klase, a ne na niz objekata
    \item Takođe, ne radi pokazivačka aritmetika, što je i logično
    \item Objekat je kolekcija elemenata, i operatorom \inlinecode{[]} pristupamo nekoj komponenti
\end{itemize}
\item Preklapanje operatora \inlinecode{()}
\begin{itemize}
    \item Mora biti nestatički metod, i ne sme biti globalna funkcija
    \item Proizvoljan broj parametara proizvoljnog tipa\\
    \inlinecode{f(a1, a2, ..., an) = f.operator()(a1, a2, ..., an)}\\
    \inlinecode{o(a1, a2, ..., an) // o je objekat neke klase}
    \item Klasa sa \inlinecode{()} operatorom $\rightarrow$ funkcijska klasa
    \item Objekat funkcijske klase $\rightarrow$ funkcijski objekat
\end{itemize}
\item Preklapanje operatora \inlinecode{->}
\begin{itemize}
    \item Mora biti nestatički metod, i ne sme biti globalna funkcija
    \item Bez parametara iako je binarni operator\\
    \inlinecode{o->clan = (o.operator->())->clan}
    \item Ili vraća neki pokazivač na objekat klase koja sadrži \inlinecode{clan}, ili objekat (ili referencu) klase za koju je takođe definisan operator \inlinecode{->}
    \item Jedna od primena su pametni pokazivači
    \begin{lstlisting}
// Pratimo koliko puta smo pristupili odredjenom objektu
struct X { int val; };
class Xptr {
    X* p; int bp;
public:
    Xptr(X *px): p(px), bp(0) { }
    X& operator*() { bp++; return *p;}
    X* opereator->() { bp++; return p;}
};
int main() {
    X x; Xptr pp=&x;
    (*pp).val = 1;
    int i = pp->val;

}
    \end{lstlisting}
\end{itemize}
\item Preklapanje operatora \inlinecode{(tip)}
\begin{itemize}
    \item Mora biti nestatički metod, i ne sme biti globalna prijateljska funkcija
    \item Drugi način za konverziju klasnih tipova\\
    (Prvi je pomoću konstruktora konverzije)
    \item Unarni operator \inlinecode{operatorT()}
    
\item[]\begin{enumerate}
        \item Konverzija tipa klase koje je objekat u tip T
        \item T može biti standardni, pokazivački ili klasni tip
    \end{enumerate} 
    \item Nema parametara
    \item Tip rezultata ne sme da bude naveden u deklaraciji/definiciji jer se podrazumeva na osnovu imena
    \item Pozivanje
    \begin{enumerate}
        \item \inlinecode{T(x), (T)x} $\iff$ \inlinecode{X.operatorT()} 
        \item \inlinecode{static\_cast<T>(x)}
    \end{enumerate}
    \item Razlike između konstruktora konverzije i preklopljenog operatora
    \begin{enumerate}
        \item Može da se koristi za T koje je standardni tip
        \item Operand x mora biti objekat klase X, odnosno ne može biti primitivan tip
    \end{enumerate}
    \item T(x) ne može da se koristi ako je tip sa većim brojem reči\\
    \inlinecode{unsigned long (x)} $\neq$ \inlinecode{(unsigned long) x}
    \item Konverzija može biti i implicitna
    \item Ako ne želimo implicitnu konverziju dodajemo \inlinecode{explicit}
    \item Konverzija se primenjuje automatski, ako je izbor jednoznačan
    \begin{enumerate}
        \item Ako imamo konstruktor konverzije i \inlinecode{operatorT}, t=x X
        \item Ako su definisane konverzije T(x), X(t) i \inlinecode{operator+}, x+t X
    \end{enumerate}
    \item Pri prenosu paramtera po referenci, rezultat konverzije stvarnog argumenta je privremeni objekat, pa se u funkciji prenosi njegova adresa, i izmene u funkciji se odnose samo na taj objekat
    \begin{lstlisting}
class X {
public:
    operator int() { return 1; }
    explicit operator double() { return 2; }
};
/*...*/
int a=X();                  // a == 1
int b = (int) X();          // b == 1
double c = (double) X();    // c == 2.0
double d = X();             // d == 1.0
    \end{lstlisting}
\end{itemize}
\item Preklapanje \inlinecode{new} i \inlinecode{delete}
\begin{itemize}
    \item Preuzimanje kontrole nad alokacijom memorije
    \item Oba metoda su statička, čak i ako nisu eksplicitno tako deklarisane
    \item Pozivaju se za objekat koji u datom trenutku ne postoji
    \item Unutar tela ovih funkcija
    \begin{enumerate}
        \item Ne treba eksplicitno pozivati konstruktor/destruktor
        \item Ove operacije se pozivaju implicitno pre (kod \inlinecode{new}) ili posle (kod \inlinecode{delete})
    \end{enumerate}
    \item Služe samo da rezervišu ili oslobode prostor za objekat
\end{itemize}
\item Preklapanje \inlinecode{new}
\begin{itemize}
    \item \inlinecode{void* operator new (size\_t sz, T1 t, ..., TN tn)}\\
    \inlinecode{void* operator new[](size\_t sz, T1 t, ..., TN tn)}
    \item \inlinecode{size\_t} je celobrojni tip definisan u \inlinecode{<stddef.h>} (C), odnosno u \inlinecode{<cstddef>} (C++)
    \item Parametar \inlinecode{sz} daje veličinu prostora koji treba alocirati u bajtima
    \item Argument za \inlinecode{sz} je \inlinecode{sizeof(T)}, i formira se na osnovu tipa T
    \item Opciona lista izraza je inicijalizator
    \item \inlinecode{operator new} vrati pokazivač na alocirani prostor
    \item Klasa može imati više preklopljenih \inlinecode{new}
    \begin{lstlisting}
new (arg2, ..., argN) T(izraz, ..., izraz)
new (arg2, ..., argN) T[duzina]
    \end{lstlisting}
\end{itemize}
\item Preklapanje \inlinecode{delete}
\begin{itemize}
    \item \inlinecode{velicina} određuje prostoro koji treba osloboditi u bajtovima
    \item Ako ga nema, funkciaj mora sama da odredi veličinu na osnovu ranije alokacije
    \item Ne vraća rezultat
    \item Samo po 1 \inlinecode{delete} po klasi za podatak i niz
    \begin{lstlisting}
void operator delete (void* pokazivac);
void operator delete (void* pokazivac, size_t velicina);
void operator delete[] (void* pokazivac);
void operator delete[] (void* pokazivac, size_t velicina);
    \end{lstlisting}
\end{itemize}
\item Dohvatanje ugrađenih \inlinecode{new} i \inlinecode{delete}
\begin{itemize}
    \item Eksplicitno $\rightarrow$ korišćenjem \inlinecode{::}
    \item Implicitno $\rightarrow$ samo za druge tipove
    \item \inlinecode{new} i \inlinecode{delete} ne mogu biti virtuelni, ali se nasleđuju normalno
    \begin{lstlisting}
#include <cstddef>
using namespace std;
class XX {
public:
    void* operator new (size_t sz) { return new char [sz]; } // ugradjeni new
    void operator delete (void* p) { delete [] p; } // koristi se ugradjeni delete
};
    \end{lstlisting}
\end{itemize}
\item Standardni U/I tokovi
\begin{itemize}
    \item Kao ni C, ni C++ nema ugrađene U/I naredbe i realizuju se pomoću standardne biblioteke
    \item Standardna biblioteka C++ je napisana u duhu OOP-a
    \item Mogu se koristiti i C funkcije (\inlinecode{scanf, printf}), ali nije preporučljivo
    \item C++ biblioteka je \inlinecode{<iostream>}
    \item Dve osnovne klase
    \begin{enumerate}
        \item \inlinecode{istream} - \textit{input stream}
        \item \inlinecode{ostream} - \textit{output stream}
    \end{enumerate}
    \item Iz navedenih klasa izvedene su i klase \inlinecode{ifstream} i \inlinecode{ofstream} za rad sa datotekama
    \item Pristup datotekama isključivo preko klasa
\end{itemize}
\item Standardni objekti i operacije za U/I
\begin{itemize}
    \item Dva globalna objekta
    \begin{enumerate}
        \item \inlinecode{cin} iz \inlinecode{istream} - obično povezan sa tastaturom
        \item \inlinecode{cout} iz \inlinecode{ostream} - obično povezan sa monitorom
    \end{enumerate}
    \item Preklopljeni su operatori \inlinecode{<<} i \inlinecode{>>} za sve standardne tipove\\
    \inlinecode{istream\& operator>>(istream\& is, T\& t);}\\
    \inlinecode{ostream\& operator<<(ostream\& os, const T\& t);}
    \item Rezultati su reference pa samim tim dozvoljavaju \textbf{ulančavanje}
\end{itemize}
\item Korišćenje operatora \inlinecode{<<} i \inlinecode{>>}
\begin{itemize}
    \item Vraćaju referencu na levi operand $\rightarrow$ višestruki U/I u istoj naredbi
    \item Sleva-udesno asocijativni $\rightarrow$ podaci se ispisuju/učitavaju u prirodnom redosledu
    \item Za jednostavne U/I operacije
\end{itemize}
\item Preklapanje operatora \inlinecode{<<} i \inlinecode{>>}
\begin{itemize}
    \item Mora uvek da se koristi globalna prijateljska funkcija zbog toga što je levi operand tipa \inlinecode{istream\&} ili \inlinecode{ostream\&}, a ne trenutni objekat klase
    \begin{lstlisting}
#include <iostream>
using namespace std;
class Kompleksni {
    double real, imag;
    friend ostream& oeprator<<(ostream&, const Kompleksni&);
public: /* ... */
};
ostream& operator<<*ostream& os, const Kompleksni& c){
    return os<<"("<<c.real<<", "<<c.imag<<")";
}
void main() {
    Kompleksni c(0.5, 0.1);
    cout<<"c="<<c<<endl; // ISPIS: c=(0.5,0.1)
}
    \end{lstlisting}
\end{itemize}
\item Operatori za nabrajanja
\begin{itemize}
\begin{multicols}{2}
\item Celobrojni tip, ali su dozvoljene
    \begin{enumerate}
        \item Operacije dodele istom tipu nabrajanja
        \item Operacija konverzije u celobrjnu vrednost - može i implicitno (osim za nabrajanja sa ograničenim dosegom)
        \item Operacija konverzije iz celobrojne vrednosti - samo eksplicitno
    \end{enumerate}
    \item Dozvoljeno preklapanje operatora koji se ne preklapaju kao metodi
    \begin{enumerate}
        \item Ne može \inlinecode{=, [], (), ->, (tip), new, delete}
        \item Ugrađeni \inlinecode{= i (tip)} zadovoljavaju realne potrebe, ostali nemaju mnogo smisla
    \end{enumerate}
    \columnbreak
    \begin{lstlisting}
enum Dani { PO, UT, SR, CE, PE, SU, NE};
inline Dani operator+(Dani d, int k) {
    k=(int(d)+k)%7;
    if(k<0) k+=7;
    return Dani(k);
}
inline Dani& operator+=(Dani& d, int k) {
    return d=d+k;
}
inline Dani& operator++(Dani& d) {
    return d=Dani(d<NE?int(d)+1:PO);
}
inline Dani operator++(Dani& d, int) {
    Dani e(d);
    ++d;
    return e;
}
    \end{lstlisting}
\end{multicols}
    
\end{itemize}
\end{xitemize}
\begin{center}
ER KOLOKVIJUM
\end{center}
\hzline
\section{Izvođenje klasa}
\begin{xitemize}
\item Pojam specijalizacije opšteg
\begin{itemize}
    \item Jedna klasa može biti podvrsta neke druge klase
    \item Klasa B je specijalni slučaj (\textit{a-kind-of}) klase A
    \item Objekat klase B je (\textit{is-a}) i objekat klase A
\end{itemize}
\item Izvođenje i nasleđivanje
\begin{itemize}
    \item Objekti klase B imaju sve osobine klase A, sa još nekim, specifičnim, osobinama
    \item Specijalnija klasa B se izvode iz generalnije (opštije) klase A
    \item Klasa B nasleđuje
    \begin{enumerate}
        \item Strukturne karakteristike (atribute)
        \item Karakteristike ponašanja (metode)
    \end{enumerate}
    \item Pored nasleđenih ima i svoje čanove
    \item Nasleđivanje (\textit{inheritance}) ili generalizacija/specijalizaicija\\\\
    \begin{figure}[h]
    \centering
    \begin{tikzpicture}
    \begin{umlpackage}{IZVODJENJE}
    \umlclass[]{A}{}{}
    \umlclass[x=3]{B}{}{}
    \umlinherit[]{B}{A}
    \end{umlpackage}
    \end{tikzpicture}
    \caption{Klasa B je izvedena iz klase A} 
    \end{figure}
    \item Termini
    % Mrzelo me da pravim tabelu iskren da budem
    \item[] \hspace{0.8cm}\textbf{A} \hspace{1.8cm}\textbf{B}
    \begin{enumerate}
        \item \textit{base} \hspace{1.1cm} \textit{derived}
        \item \textit{superclass} \hspace{0.32cm} \textit{subclass}
        \item \textit{parent} \hspace{1cm} \textit{child}
    \end{enumerate}
    \item Jezik je \textbf{objektno-orijentisan} ako podržava nasleđivanje, a \textbf{objektno-baziran} u suprotnom
    \item Pri izvođenju nije potrebno menjati postojeće klase
    \item Postojeće klase se \textbf{ne} prevode ponovo
\end{itemize}
\item Definisanje izvedene klase\\
\inlinecode{class ime: ime\_osnovne \{ ... \};}
\begin{itemize}
    \item Ako postoji samo jedna osnovna klasa $\rightarrow$ \textbf{jednostruko izvođenje}
    \item Ako postoji više osnovnih klasa $\rightarrow$ \textbf{višestruko izvođenje}
    \item \boxedimportant[NIJE VIŠESTRUKO]{Izvođenje može biti i u više koraka, gde je izvedena klasa osnovna klasa za sledeće izvođenje}
\end{itemize}
\item Konačna klasa
\begin{itemize}
    \item Modifikator \inlinecode{final} $\rightarrow$ dalje se ne može izvoditi
    \item \inlinecode{final} nije rezervisana reč, može biti i identifikator ali se ne preporučuje
\end{itemize}
\begin{multicols}{2}
\item Primer izvođenja
\begin{itemize}
    \item Objekat izvedene klase sadrži
    \begin{enumerate}
        \item Bezimeni podobjekat osnovne klase koji sadrži nasleđene članove
        \item Specifične čanove navedene u definiciji izvedene klase
    \end{enumerate}

\end{itemize}
\item Pristup nasleđenim članovima
\begin{itemize}
    \item Javnim članovima osnovne klase se pristupa isto kao i članovima izvedene klase
\end{itemize}
\columnbreak
\begin{lstlisting}
class Osnovna { private: int i;
public: void f();
};
class Izvedena: public Osnovna { private: int j;
public: void g();
};
int main() {
    Osnovna b; Izvedena d;
    b.f();
    b.g(); // ERROR: g je metod izvedene
    d.f(); d.g(); // OK
}
    \end{lstlisting}
\end{multicols}
\item Konstruktor, destruktor, \inlinecode{operator=}
\begin{itemize}
    \item Izvedena klasa ih \textbf{ne} nasleđuje
    \item Kao i za osnovne klase, postoje ugrađeni
    \begin{enumerate}
        \item Podrazumevani konstruktor praznog tipa
        \item Kopirajući konstruktor koji kopira član po član (plitka kopija)
        \item Premeštajući konstruktor koji kopira član po član
        \item Destruktor praznog tela
        \item Kopirajući operator dodele koji vrši dodelu kopiranjem, član po član
        \item Premeštajući operator dodele koji vrši dodelu premeštanjem, član po član
    \end{enumerate}
\end{itemize}
\item Prava pristupa
\begin{itemize}
    \item Članovi izvedene klase imaju prava pristupa javnim članovima osnovne klase, a nemaju pristup privatnim
    \item  Posebno pravo pristupa - \textbf{zaštićeno}\\
    \inlinecode{protected:}
    \item Označava de klase kojem imaju pravo pristupa metode te i izvedenih klasa - \textit{zašto te?}
    \item Zaštićenim članovima može da se pristupi iz metoda izvedene klase kao nasleđenim članovima
    \begin{lstlisting}
class Osnovna {
            int pb;
protected:  int zb;
public:     int jb;
};
class Izvedena : public Osnovna {
public:
    void m(int x) {
        jb=zb=x;    // OK
        pb=x;       // ERROR: privatni clan
        Osnovna c;
        o.zb=x;     // ERROR: ne moze preko osnovne
    }
};
void f(){
    Osnovna b;
    b.pb=1; // ERROR: privatan clan
    b.zb=1; // ERROR: zasticeni clan
    b.jb=1; // OK
}
    \end{lstlisting}
\end{itemize}
\item Načini izvođenja
\begin{multicols}{2}

\begin{itemize}
    \item Određuje ga modifikator ispred imena osnovne klase
    \item Može biti
    \begin{enumerate}
        \item Javno \inlinecode{public}
        \item Zaštićeno \inlinecode{protected}
        \item Privatno \inlinecode{private}
    \end{enumerate}
    \item Kaže se i za osnovnu klasu da je javna, zaštićena ili privatna
    \item Podrazumevano izvođenje je privatno
    \item Način izvođenja određuje nasleđivanje prava pristupa
    \item Određu se se stepen kontrole pristupa članovima osnovne klase preko objekta izvedene klase
    \item Objekat izvedene klase može biti osnovna klasa u dalje izvođenju
    \item Ne utiče na pravo pristupa iz metoda dotične izvedene klase
    \begin{table}[ht]
    \begin{tabular}{|l|lll}
    \hline
    \multicolumn{1}{|c|}{}                                     & \multicolumn{3}{c|}{\textbf{član osnovne klase}}                                                                       \\ \cline{2-4} 
    \multicolumn{1}{|c|}{\multirow{-2}{*}{\textbf{Izvođenje}}} & \multicolumn{1}{l|}{\textbf{javni}} & \multicolumn{1}{l|}{\textbf{zaštićeni}} & \multicolumn{1}{l|}{\textbf{privatan}} \\ \hline
    \textbf{javno}                                             & \cellcolor[HTML]{DAE8FC}javni       & \cellcolor[HTML]{DAE8FC}zaštićen        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \textbf{zaštićeno}                                         & \cellcolor[HTML]{DAE8FC}zaštićen    & \cellcolor[HTML]{DAE8FC}zaštićen        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \textbf{privatno}                                          & \cellcolor[HTML]{DAE8FC}privatan    & \cellcolor[HTML]{DAE8FC}privatan        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \end{tabular}
    \end{table}
    
\end{itemize}
\columnbreak
\end{multicols}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|lll}
    \hline
    \multicolumn{1}{|c|}{}                                     & \multicolumn{3}{c|}{\textbf{Član osnovne klase}}                                                                       \\ \cline{2-4} 
    \multicolumn{1}{|c|}{\multirow{-2}{*}{\textbf{Izvođenje}}} & \multicolumn{1}{l|}{\textbf{javni}} & \multicolumn{1}{l|}{\textbf{zaštićeni}} & \multicolumn{1}{l|}{\textbf{privatan}} \\ \hline
    \textbf{javno}                                             & \cellcolor[HTML]{DAE8FC}javni       & \cellcolor[HTML]{DAE8FC}zaštićen        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \textbf{zaštićeno}                                         & \cellcolor[HTML]{DAE8FC}zaštićen    & \cellcolor[HTML]{DAE8FC}zaštićen        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \textbf{privatno}                                          & \cellcolor[HTML]{DAE8FC}privatan    & \cellcolor[HTML]{DAE8FC}privatan        & \cellcolor[HTML]{DAE8FC}privatan       \\ \cline{1-1}
    \end{tabular}
    \end{table}
\item Eksplicitna promena prava pristupa
\begin{itemize}
    \item Može eksplicitno da se promeni pravo pristupa nasleđenom članu
    \begin{enumerate}
        \item Da se uveća u odnosu na originalno\\
        (zaštićeni postaje javni)
        \item Može da se restaurira na originalnu koje je umanjeno načinom izvođenja
        \item Delimično da se restaurira
        \item Da se umanji u odnosu na originalno
    \end{enumerate}
    \item Ne može da se promeni pravo pristupa privatnom članu osnovne klase
    \item Postiže se uvozom člana u odgovarajuću sekciju izvedene klase\\
    \inlinecode{using klasa::clan}
    \item Može i bez \inlinecode{using}, ali izbegavati
    \begin{multicols}{2}
    \begin{lstlisting}
class O {
             int pb;
protected:   int z1b, z2b;
public:      int j1b, j2b;
};
class PI: O {
public:
    using O::j1b;   
    // Vracanje starog prava pristupa
    using O::z1b;   
    // Povecanje prava pristupa
    PI() { z2b = 1; }
protected:
    using O::j2b;   
    // Delimicno vracanje prava pristupa
};
\end{lstlisting}
    \columnbreak
        \begin{lstlisting}
class IPI: public PI {
public:
    IPI() {
        j1b=0;      // OK
        j2b=0;      // OK
        z1b=0;      // OK
        z2b=0;      // ERROR
    }
};
int main() {
    PI pi;
    pi.j1b=0;       // OK
    pi.j2b=0;       // ERROR: zasticen clan
    pi.z1b=0;       // OK
    pi.z2b=0;       // ERROR: privatni clan
}
    \end{lstlisting}
    \end{multicols}
  
\end{itemize}
\item Razlika između privatnog i javnog izvođenja
\begin{itemize}
    \item Javno izvođenje realizuje koncept nasleđivanja
    \begin{enumerate}
        \item \textbf{B je vrsta A} (\textit{a-kind-of})
        \item Izvedena klasa zadržava interfejs roditelja
        \item Objekat izvedene klase može da zameni objekat osnovne
        \item Jedino pravo nasleđivanje
    \end{enumerate}
    \item Privatno izvođenje realizuje koncept sadržanja
    \begin{enumerate}
        \item \textbf{A je deo B} (\textit{a-part-of})
        \item Semantički slično kao kad B sadrži atribut tipa A
        \item Nije nasleđen interfejs jer sve nasleđeno postaje privatno
        \item Objekat izvedene klase ne može da zameni objekat osnovne
    \end{enumerate}
    \item Zaštićeno izvođenje
    \begin{enumerate}
        \item Unutar izvedene klase $\rightarrow$ koncept nasleđivanja
        \item Van izvedene klase $\rightarrow$ koncept sadržanja
    \end{enumerate}
\end{itemize}
\item Sakrivanje članova
\begin{itemize}
    \item Redefinisanje identifikatora člana osnovne klase u izvedenoj pritom sakrivajući originalni
    \item  Pristup originalu:\\
    \inlinecode{osnovna\_klasa::clan}
    \item Ako u izvedenoj klasi napišemo neki metod koji ima ime kao neki metod u osnovnoj klasi
    \begin{enumerate}
        \item Takav metod sakriva sve nasleđene metode istog imena
        \item Iz metoda izvedene klase se ne može pristupiti skrivenim metodama
        \item Nasleđeni sakriveni metodi se ne mogu pozivati ni za objekte izvedene klase (osim preko pokazivača na osnovni tip objekta)
    \end{enumerate}
\end{itemize}
\item Uvoz članova
\begin{itemize}
    \item U izvedenoj klasi sve sakrivene metode treba
    \begin{enumerate}
        \item Redefinisati
        \item Restaurirati
    \end{enumerate}
    \item Nije dobro da izvedena klasa sadrži samo neke metode osnovne
    \begin{enumerate}
        \item Nije pravo nasleđivanje
        \item Korisnik klase očekuje isti ili prošireni interfejs
    \end{enumerate}
    \item Uvoz \\
    \inlinecode{using::osnovna\_klasa::ime\_metoda}
    \item Nisu vidljivi samo metodi osnovne klase sa istim potpisom kao izvedena klasa
    \item Ne može da se restaurira vidljivost pojedinačnog metoda osnovne klase
    \begin{multicols}{2}
\begin{lstlisting}
class O { 
public:
    int a=1;
    void m1();
    void m1(int);
    void m2();
    void m2(int);
};
class I: public O {
public:
    using O::m2;
    int a=2;
    void m1(int);
    void m2(int);
    void m(){
    int x=a;        // x=I::a
    int y=O::a;     // x=O::a
    m1();           // ERROR
\end{lstlisting}
\columnbreak
\begin{lstlisting}
    m1(x);          // I::m1(int)
    O::m1();        // O::m1();
    O::m1(y);       // O::m1(int);
    m2();           // O::m2();
    m2(x);          // I::m2(int)
    O::m2(y);       // O::m2(int);
} };
void f(){
    I i;
    int p=i.a;      // I::a
    int q=i.O::a;   // O::a
    i.m1();         // ERROR
    i.O::m1();      // O::m1()
    i.m1(p);        // I::m1(int)
    i.O::m1(q);     // O::m1(int)
    i.m2();         // O::m2()
    i.m2(p);        // I::m2(int)
    i.O::m2(q);     // O::m2(int)
\end{lstlisting}
\end{multicols}
\end{itemize}
\item Uvoz konstruktora
\begin{itemize}
    \item Konstruktori osnovne klase se ne nasleđuju
    \item Može se izvršiti uvoz svih konstruktora osnovne klase\\
    \inlinecode{using ime\_klase::ime\_klase}
    \item Na taj način se generišu konstruktori izvedene sa istim potpisima
    \item Generisani konstruktor izvedene klase imaju prazno telo, samo pozivaju konstruktore osnovne sa istim potpisom
      % ne znam...
    

\begin{lstlisting}
class A { public: A(int i){...} };
class B: public A {public: using A::A; }
B b(1); // poziva se A::A(1)    
\end{lstlisting}
\end{itemize}
\item Izvođenje struktura
\begin{itemize}
    \item Strukture su ravnopravne sa klasama
    \begin{enumerate}
        \item Izvođenje strukture iz klase/strukture - javno
        \item Izvpđenje klase iz strukture - privatno
    \end{enumerate}
    \item Unije se ne mogu izvoditi, niti se može izvoditi iz njih
    \begin{lstlisting}
struct OS { };
class OK { };
class IKS: OS{ };       // privatno izvodjenje
class IKK: OK{ };       // privatno izvodjenje
struct ISK: OK{ };      // javno izvodjenje
struct ISS: OS{ };      // javno izvodjenje
    \end{lstlisting}
\end{itemize}
\item Konstruktori i destruktori
\begin{itemize}
    \item Prilikom kreiranja objekata izvedene klase poziva se konstruktor te klase, ali i konstruktor osnovne klase
    \item Analogno za uništavanje objekata (ovo se ne odnosi na redosled, već samo da se obe operacije izvršavaju)
    \item Prenos parametara u konstruktor osnovne klase
    \begin{enumerate}
        \item U listu inicijalizatora konstruktora izvedene klase moguće je upisati i inicjalizator osnovne klase
        \item Inicijalizator osnovne klase se sastoji od imena klase i argumenata poziva konstruktora
    \end{enumerate}
    \item Nije moguće vršiti inicijalizaciju pojedinih nasleđenih atributa
\end{itemize}
\item Redosled konstrukcije
\begin{itemize}
    \item Pri kreiranju objekta izvedene klase 
    \begin{enumerate}
        \item Inicijalizuje se podobjekat osnovne klase
        \begin{itemize}
            \item[-] Pozivom odgovarajućeg konstruktora osnovne klase
            \item[-] U slučaju višestrukog izvođenja, inicijalizacija po redosledu u definiciji, a ne u listi inicijalizatora
        \end{itemize}
        \item Inicijalizuju se specifični atributi
        \begin{itemize}
            \item[-] Po redosledu navođenja u definiciji a ne u listi inicijalizatora
            \item[-] Klasni tipovi pozivom odgovarajućeg konstruktora
            \item[-] Ugrađeni tipovi na osnovu inicijalizatora
            \item[-] Nizovi objekata po redosledu rastućeg indeksa podrazumevanim konstruktorom
        \end{itemize}
        \item Telo konstruktora
    \end{enumerate}
    \item Pri uništavanju objekta izveden klase, redosled poziva destruktora je obratan
\end{itemize}
\item Konverzija
\begin{itemize}
    \item Objekat javno izvedene klase je i objekat osnovne (\textit{Liskov substitution principle})
\end{itemize}
\begin{enumerate}
    \item Pokazivač na objekat izvedene klase može se implicitno konvertovati u pokazivač na objekat osnovne klase
    \item Pokazivač na objekat osnovne klase mora se eksplicitno konvertovati u pokazivač na objekat izvedene klase
    \item Isto važi za reference
    \item Objekat osnovne klase se može inicijalizovati objektom izvedene klase
    \item Objektu osnovne klase se može dodeliti objekat izvedene klase
\end{enumerate}
\begin{itemize}
    \item Objekat privatno/zaštićeno izvedene klase nije i objekat osnovne klase
    \item Pokazivač na objekat takve klase se može implicitno konvertovati u pokazivač na objekat osnovne klase samo unutar izvedene klase
\end{itemize}
\item Pojam polimorfizma
\begin{itemize}
    \item Izvedena klasa može da definiše određene metode na svoj način
\end{itemize}
\item Decentralizacija odgovornosti
\begin{itemize}
    \item Svaki objekat prepozna kojoj izvedenoj klasi pripada iako možemo da mu se obraćamo kao objektu osnovne klase
    \item \textbf{Polimorfizam} - svaki objekat izvedene klase izvršava metod onako kako je to definisano u njegovoj izvedenoj klasi, iako mu se pristupa kao objektu osnovne klase
    \item \textit{Polymorphism = poly} (više) \textit{ + morph} (oblik)
    \item Isti metod ima više oblika
    \item Mehanizam je potpuno dinamički - klasa objekta se određuje pri \textbf{izvršavanju} programa
\end{itemize}
\item Virtuelni (polimorfni) metodi
\begin{itemize}
    \item Virtuelni metodi su metodi osnovne klase koji se u ivzedenim klasama mogu redefinisati
    \item Metod u izvedenoj klasi nadjačava (\textit{override}) metod osnovne klase
    \item Polimorfna klasa je ona koja sadrži barem jedan virtuelni metod\\
    \inlinecode{virtual tip ime(...)}
    \item Prilikom deklarisanja virtuelnih metoda u izvedenim klasama $\rightarrow$ ne mora \inlinecode{virtual}
    \item Pozivom preko pokazivača/referece na osnovnu klasu - izvršava se onaj metod koji pripada klasi pokazanog objekta
\end{itemize}
\item Redefinisanje virtuelnih metoda
\begin{itemize}
    \item Deklaracija virtuelnog metoda u izvedenoj klasi mora \textbf{potpuno} da se slaže sa deklaracijom u osnovnoj klasi (broj + tipovi argumenata + tip rezultata)
    \item U specijalnom slučaju, ako je tip rezultata referenca/pokazivač na osnovnu kasu, tada, redefinisani metod može da vrati pokazivač/referencu na javno izvedenu klasu iz date osnovne
    \item Neslaganje potpisa $\rightarrow$ sakrivanje metoda
    \item Samo razlika u tipu rezultata $\rightarrow$ greška
    \item Virtuelni metod ne mora da se redefiniše u svakoj izvedenoj klasi - tamo gde nije, naseldi osnovni metod
\end{itemize}
\item Pozivanje virtuelnih metoda
\begin{itemize}
    \item Mehanizam se aktivira samo ako se objektu pristupa indirektno - preko reference ili pokazivača
    \begin{lstlisting}
class Osnovna { public: virtual void f(); };
class Izvedena : public Osnovna { public: void f(); };
void g1(Osnovna b) { b.f(); }
void g2(Osnovna *pb) { pb->f(); }
void g3(Osnovna &rb) { rb.f(); }
int main () {
Izvedena d;
g1(d);                                  // poziva se Osnovna::f
g2(&d);                                 // poziva se Izvedena::f
g3(d);                                  // poziva se Izvedena::f
Osnovna *pb=new Izvedena; pb->f();      // poziva se Izvedena::f
Osnovna &rb=d; rb.f();                  // poziva se Izvedena::f
Osnovna b=d; b.f();                     // poziva se Osnovna::f
delete pb; pb=&b; pb->f();              // poziva se Osnovna::f
}
    \end{lstlisting}
\end{itemize}
\item Modifikatori \inlinecode{override} i \inlinecode{final}
\begin{itemize}
    \item Implicitna vrednost metoda u izvedenoj klasi nije rObUsNa
    \item Kao modifikator (iza liste parametara) može da se navede modifikator \inlinecode{override}
    \item Eksplicitno se iskazuje da metod nadjačava odgovarajući virtuelni metod
    \item Prevodilac prijavljuje grešku ako nema odgovarajućeg virtuelnog metoda
    \item Modifikator \inlinecode{final} sprečava nadjačavanje virtuelnih metoda u izvedenim klasama
    \item Ovi modifiaktori \textbf{nisu} rezervisane reči, niti deo potpisa metoda
    \item Moguća kombinacija i \inlinecode{override} i \inlinecode{final}
      % ne znam...
    \begin{lstlisting}
class A { public:
virtual void vm1();
virtual void vm1(int);
void m1();
};
class B: public A {public:
void vm1() override;
void vm1(int) override final;
void vm1(float) override;           // ERROR - nema A::vm1()
void vm2() override;                // ERROR - nema A::vm2()
void m1() override;                 // ERROR - A::m1() nije virtuelna
void m2() final;                    // ERROR - B::m2() nije virtuelna
};
class C: public B { public:
void vm1(int);                      // ERROR - B::vm1(int) je konacna
};
int override=1; int final=2;        // U redu, nije preporucljivo
    \end{lstlisting}
\end{itemize}
\item Dinamičko vezivanje
\begin{itemize}
    \item Dinamičko vezivanje - \textit{Dynamic binding} je mehanizam koji obezbeđuje da se metod koji se poziva određuje 
    \begin{enumerate}
        \item Po tipu objekta
        \item Ne po tipu pokazivača ili reference na taj objekat
    \end{enumerate}
    \item Odlučivanje koji će se virtuelni metod pozvati se obavlja \textbf{dinamički} - u toku programa
    \item Po tome se razlikuje u odnosu na preklapanje
\end{itemize}
\item Implementacija virtuelnih poziva
\begin{itemize}
    \item Za jednostruko nasleđivanje
    \begin{enumerate}
        \item Za virtuelne metode nove klase $\rightarrow$ jedinstven kod metoda
        \item Za svaku polimorfnu klasu postoji tabela pokazivača na virtuelne metode te klase - \textbf{TVF} - Tabela virtuelnih funkcija
        \end{enumerate}
        %ubaciti sliku?
\end{itemize}
\item Osobine polimorfnih metoda
\begin{itemize}
    \item Virtuelni metodi ne mogu biti statički
    \item Ako nam treba statički metod sa polimorfnim ponašanjem
    \begin{enumerate}
        \item Obaj metod treba da poziva nestatički virtuelni metod za neki objekat
        \item Pokazivač/referenca na taj objekat se prenosi kao argument poziva statičkog metoda
    \end{enumerate}
    \item Globalne prijatljeske funkcije \textbf{ne mogu} biti polimorfne (ako je potrebno, mora biti implementirano kao i kod statičkih metoda)
    \item Virtuelni metodi mogu biti prijatelji drugih klasa
\end{itemize}
\item Virtuelni destruktor
\begin{itemize}
    \item Konstruktor ne može biti virtuelna funkcija jer se poziva pre nego što se objekat kreira
    \item Destruktor može biti virtuelna funkcija
    \item Tek u vreme izvršenja se zna koji destruktor pozivamo
    \item Kada se uništava dinamički objekat, destruktor osnovne klase se uvek izvršava, ili kao jedini, ili posle destruktora izvedene klase
    \item Kada neka klasa ima virtuelnu funkciju, verovatno i njen destruktor treba da bude virtuelan
    \item Unutar destruktora izvedene klase ne treba pozivati destruktor osnovne
    \begin{lstlisting}
class OVD { public: virtual ~OVD(); };
class IVD: public OVD { public: ~IVD(); };
class OnVD{ public: ~OnVD(); };
class InVD: public OnVD { public: ~InVD(); };
void oslobodi (OVD *pb) { delete pb; }
void oslobodi (OnVD *pb) { delete pb; }
int main () {
OVD *pb=new OVD; oslobodi(pb);              // ~OVD()
IVD *pd=new IVD; oslobodi(pd);              // ~IVD(), ~OVD()
OnVD *pbn=new OnVD; oslobodi(pbn);          // ~OnVD()
InVD *pdn=new InVD; oslobodi(pdn);          // ~OnVD()
}
    \end{lstlisting}
\end{itemize}
\item Nizovi i izvođenje
\begin{itemize}
    \item U C++, niz objekata nije objekat
    \item Niz objekata izvedene klase nije jedna vrsta niza objekata osnovne klase
    \item Ako se niz objekata izvedene klase prenese funkciji koja očekuje niz osnovne klase, može doći do greške
    \item Objekti osnovne klase su manj od izvedeni objekata, a funkcija smatra da je dobila niz objekata osnovne klase
    \begin{lstlisting}
class Osnovna { public: int bi; };
class Izvedena : public Osnovna { public: int di; };
void f(Osnovna *b, int i) { cout<<b[i].bi; }
int main () {
Izvedena d[5];
d[2].bi=77;
f(d,2); // nece se ispisati 77
}
    \end{lstlisting}
\end{itemize}
\item Prenos zbirki objekata funkcijama
\begin{itemize}
    \item Ako je u igri nasleđivanje pravilo je da se koriste nizovi pokazivača na objekte umesto nizova objekata
    \item Nije dozvoljena konverzija \inlinecode{Izvedena**} u \inlinecode{Osnovna**}
\end{itemize}
\item Apstraktni metodi i klase
\begin{itemize}
    \item Apstraktni metod je virtuelni metod koji nije definisan za osnovnu klasu
    \item Umesto tela stoji \inlinecode{= 0}
    \item Klasa koja sadrži bar 1 apstraktan metod naziva se apstraktnom klasom - \textit{abstract class}
    \item Apstraktna kalsa ne može imati objekte, već stiže samo za izvođenje
    \item Mogu se formirati pokazivači i reference na apstraktnu klasu
    \item Pokazivači i reference na asptraktnu klasu mogu samo da pokazuju na objekte izvedenih klasa
    \begin{lstlisting}
class Osnovna {
public:
virtual void cvf () = 0;                // apstraktni metod
virtual void vf ();                     // virtuelni metod
};
class Izvedena : public Osnovna {
public:
void cvf();
};
int main () {
    Izvedena izv, *pi=&izv;
    Osnovna osn;                        // ERROR - Osnovna je apstraktna klasa
    Osnovna *po=&izv;
    po->cvf();                          // Poziva se Izvedena::cvf()
    po->vf();                           // Poziva se Osnovna::vf()
}
    \end{lstlisting}
\end{itemize}
\item Apstraktni destruktor
\begin{itemize}
    \item Kada treba sprečiti stvaranje objekta čiji su svi metodi konkretni, a ne apstraktni deklarišemo apstraktni destruktor
    \item \boxedimportant[ZAŠTO?]{\item Apstraktni destruktor mora biti definisan i za osnovnu klasu, a definicija mora biti van tela klase}
    \item Postojanje definicije za destruktor omogućava kreaciju podklasnih objekata
      
    \begin{lstlisting}
class O {
public:
virtual ~O() = 0;
};
O::~O(){}
class I:public O {};
O o; // ERROR
I i; // U redu
    \end{lstlisting}
\end{itemize}
\item Generalizacija i konkretizacija
\begin{itemize}
    \item Apstraktna klasa predstavlja \textbf{generalizaciju} izvedenih klasa
    \item Klasa koja se izvodi iz apstraktne je \textbf{konkretizacija} apstraktne klase
    \item Ako se u izvedenoj klasi ne navede definicija nekog apstraktnog metoda iz osnovne klase, i izvedena klasa je apstraktna
    \item Apstraktna klasa može imati konstruktor - pozivaće se kao konstruktor osnovne klase pri konstrukciji objekata izvedenih konkretnih klasa
\end{itemize}
\item Problem konverzije naniže
\begin{itemize}
    \item Preko pokazivača/reference na osnovnu klasu nije moguće pristupiti članovima izvedene klase
    \item Samo ako znamo tačan tip objekta na koji ukazuje pokazivač/referenca možemo eksplicitno konvertovati pokazivač na osnovnu klasu u pokazivač na izvedenu - konverzija naniže - \textit{downcast}
    \item Ovakva konverzija uopšte nije bezbedna
    \item Rešenje je da se nakon konverzije naniže proveri njena ispravnost - operator za dinamičku konverziju tipa
\end{itemize}
\item Operator dinamičke konverzije\\
\inlinecode{dynamic\_cast<izvedena\_klasa*>(pokazivac)\\}
\inlinecode{dynamic\_cast<izvedena\_klasa\&>(referenca)}
\begin{itemize}
    \item Konvertuju pokazivač/referencu na polimorfnu osnovnu klasu u pokazivač/referencu na izvedenu klasu
    \item Ako pokazivač ne pokazuje na objekat izvedene klase u koju se vrši konverzija, ili njene podklase rezultat je \inlinecode{nullptr}
    \item Ako referenca ne upućuje na na objekat izvedene klase u koju se vrši konverzija, ili njene podklase rezultat je  \inlinecode{bad\_cast} iz \inlinecode{<typeinfo>}
    
    \begin{lstlisting}
class A {public: virtual void vm(){}};      // Polimorfna klasa
class B: public A{/*...*/};
class C: public A{/*...*/};
int main(){
    A *pa=new B();
    B *pb=dynamic_cast<B*>(pa);
    C *pc=dynamic_cast<C*>(pa);             // pc==nullptr
    B &rb=dynamic_cast<B&>(*pa);
    C &rc=dynamic_cast<C&>(*pa);            // bad_cast
}
    \end{lstlisting}
\end{itemize}
\item Dinamičko određivanje tipa
\begin{itemize}
    \item C++ omogućava da se u vreme izvršavanja (\textit{runtime}) odredi tip izraza\\
    \inlinecode{typeid(izraz)}\\
    \inlinecode{typeid(tip)}
    \item \inlinecode{izraz}
    \begin{itemize}
        \item Proizvoljnog tipa
        \item Vrednost se \textbf{ne} izračunava
        \item Ako ukazuje na polimorfnu klasu, rezultat se odnosi na dinamički tip operanda, u suprotnom na statički
        \item \inlinecode{typeid(*p) p == nullptr} $\rightarrow$ \inlinecode{bad\_typeid}
    \end{itemize}
    \item \inlinecode{tip} - proizvoljan tip, rezultat je \inlinecode{const type\_info\&}
    \item Introspekcija ili refleksija je način da program sazna o sebi

\end{itemize}
\item Klasa \inlinecode{type\_info}
\begin{itemize}
    \item \inlinecode{type\_info} je iz \inlinecode{<typeinfo>}
    \item Metodi klase \inlinecode{type\_info}
    \begin{itemize}
        \item \inlinecode{bool operator==(const type\_info\&) const;}
        \item \inlinecode{bool operator!=(const type\_info\&) const;}
        \item \inlinecode{bool before (const type\_info\&) const;} - uređuje dva objekta tipa \inlinecode{type\_info}
        \item \inlinecode{const char* name() const;} - vraća neko ime - zavisi od kompajlera
    \end{itemize}
    \item Nema javnih konstruktora, ne mogu se kreirati podaci ovog tipa, i zato se i ne mogu prenositi podaci ovog tipa po vrednosti
    \item Operator dodele je takođe privatan
    \begin{lstlisting}
class O {};
// Nepolimorfna klasa
class I: public O{public: virtual void f(){}};
class II: public I{};
int main(){
O *po=new I;
I *pi=new II;
// Izlaz (Borland):
cout<<(typeid(*po)==typeid(I))<<endl;       // 0
cout<<(typeid(*pi)==typeid(II))<<endl;      // 1
cout<<typeid(O).name()<<endl;               // O
cout<<typeid(*po).name()<<endl;             // O
cout<<typeid(*pi).name()<<endl;             // II
cout<<typeid(po).name()<<endl;              // O *
cout<<typeid(pi).name()<<endl;              // I *
int m[100][20];
cout<<typeid(m).name()<<endl;               // int[100][20]
    \end{lstlisting}
\end{itemize}
\item Zloupotreba određivanja tipa
\begin{itemize}
    \item Poenta objektno-orijantisanih jezika je u decentralizaciji odgovornosti
    \item Kada se odredi tip objekta on se može porediti sa klasama
    \item Polimorfizam se zamenjuje selekcijom i program ponovo postaje sa centralnom odgovornošću
    \begin{lstlisting}
// Ohrabruje ovakvu vrstu pisanja, preuzeto sa StackOverflow
PolymorphicType *pType = ...;
if(typeid(*pType) == typeid(Derived1))
  pType->Func1();
else if(typeid(*pType) == typeid(Derived2))
  pType->Func2();
else if(typeid(*pType) == typeid(Derived3))
  pType->Func3();
    \end{lstlisting}
\end{itemize}
\item Višestruko nasleđivanje
\begin{itemize}
    \item Klasa direktno nasleđuje osobine više osnovnih klasa, a roditeljske nisu jedna drugoj vrsta - \textit{multiple inheritance}
    \item Klasa se deklariše kao naslednik više klasa tako što se u zaglavlju navode osnovne klase - ispred svake osnovne treba da stoji \inlinecode{public}
    
\end{itemize}
\item Konstrukcija i destrukcija
\begin{itemize}
    \item Pravila o nasleđenim članovima važe
    \item Konstruktori svih osnovnih klasa se izvršavaju pre
    \begin{enumerate}
        \item Konstruktora članova izvedene klase
        \item Konstruktora izvedene klase
    \end{enumerate}
    \item Konstruktori osnovnih klasa se pozivaju po redesledu deklarisanja
    \item Destruktori osnovnih klasa se izvršavaju posle
    \begin{enumerate}
        \item Destruktora izvedene klase
        \item Destruktora članova izvedene klase
    \end{enumerate}
    \item Destruktori osnovnih klasa se pozivaju obrnutim redom
\end{itemize}
\item Problem dijamant strukture
\begin{itemize}
    \item Kada su osnovne klase, pri višestrukom izvođenju, izvedene iz iste roditeljske klase nastaje problem dijamant strukture
    \begin{lstlisting}
class B {int i; /*...*/};
class X : public B {/*...*/};
class Y : public B {/*...*/};
class Z : public X, public Y {/*...*/};  
    \end{lstlisting}
\item Objekat nove klase će imati dva skupa članova klase B - razlikujemo ih pomoću \inlinecode{z.X::i} ili \inlinecode{z.Y::i}
\item Konstruktor osnovne kase B se izvršava dva puta
\end{itemize}
\item Virtuelne osnovne klase
\begin{itemize}
    \item Ako nisu potrebna dva skupa članova, pri izvođenju treba deklarisati klasu B kao virtuelnu osnovnu klasu
\begin{lstlisting}
class B {int i; /*...*/};
class X : virtual public B {/*...*/};
class Y : virtual public B {/*...*/};
class Z : public X, public Y {/*...*/};
\end{lstlisting}
\item Sada klasa Z nasleđuje samo jedan skup klase B i nema dvoznačnosti
\item Konstruktor klase B se poziva samo jednom
\item Klasa B mora biti virtuelna osnovna i za X i za Y, ako je samo jedna virtuelna ostaje dva skupa članova sa dva konstruktora
\item Redefinicija metod \inlinecode{m()} definisanog u klasi B
\begin{itemize}
    \item U klasi X ili Y - za \inlinecode{z.m()} se poziva redifinicija \checkmark
    \item I u klasi X i u klasi Y - dvoznačnost X
\end{itemize}
\end{itemize}
\item Redosled konstrukcije
\begin{itemize}
    \item Konstruktori virtuelnih osnovnih klasa se pozivaju pre konstruktora nevirtuelnih osnovnih klasa
    \item Precizan redosled
    \begin{enumerate}
        \item Konstruktori virtuelnih osnovnih klasa prvo po dubini grafa do korena, a zatim sleva-udesno na istom nivou
        \item Konstruktori nevirtuelnih osnovnih klasa
        \item Konstruktori atributa
        \item Konstriktor izvedene klase
    \end{enumerate}
    \item Konstruktori virtulenih osnovnih klasa se pozivaju samo jednom
     
    \newpage
\begin{multicols}{2}
\begin{lstlisting}
#include <iostream.h>
class B {
public: B(){cout<<" B";}
};
class X : virtual public B {
public: X(){cout<<" X";}
};
class Y : virtual public B {
public: Y(){cout<<" Y";}
};
class Z : public X, public Y {
public: Z(){cout<<" Z"<<endl;}
};
int main(){Z z;}
\end{lstlisting}
\columnbreak
\begin{lstlisting}
// Originalni redosled:           B X Y Z
// Da je stajalo (jedna po jedna zamena):
class X: public B {...      //  B B X Y Z
class Y: public B {...      //  B X B Y Z
class Z: public X,
virtual public Y {...       //    B Y X Z
class Z: virtual public X,
virtual public Y {...       //    B X Y Z
\end{lstlisting}
\end{multicols}
\end{itemize}
\end{xitemize}
\section{ Izuzeci (\textit{Exceptions})}
\begin{xitemize}
\item Pojam izuzetaka
\begin{itemize}
    \item Izuzeci (\textit{exceptions}) su događaji koje treba posebno obraditi van toka programa
    \item Kod jezika koje ne podržavaju obradu izuzetaka, dolazi do sledećih problema
    \begin{itemize}
        \item[\textperiodcentered] Problem migracije udesno - Posle izvršenja dela programa u kojem može doći do greške se testira status. OK status ide u jednu granu \inlinecode{if}, a obrada greške u drugu
        \item[\textperiodcentered] Problem propagacije unazad - U lancu poziva funkcija, ako greška treba da se propagira nazad ka prethoodnom nivou, svaki nivo treba da testira da li je došlo do greške, i ako greška ne može da se obradi, funkcija u \inlinecode{return} mora da vrati kod greške
    \end{itemize}
    % Ilustracije problema?
\end{itemize}
\item Izuzeci u jeziku C++
\begin{itemize}
    \item Na mestu otkrivanja izuzetne situacije se baca izuzetak (operator \inlinecode{throw}) i dalja regularna obrada tekućeg bloka se trajno prekida
    \item Izuzetak može biti objekat klase ili nekog drugog tipa
    \item Obrada iuzetaka se nastavlja u posebnom bloku (\inlinecode{catch}) - rukovaocu obradom izuzetka (\textit{handler}) se dostavlja izuzetak kao argument
    \item Za svaki tip izuzetka postoji zaseban \textit{handler}
    \item Posle uspešne obrade izuzetka, obrada se nastavlja regularno
    \item Ako ne postoji odgovarajući rukovalac izuzetak se automatski propagira unazad
\end{itemize}
\item Otkrivanje i obrada izuzetaka
\begin{itemize}
    \item Obrada izuzetaka je vezana za blok naredbe \inlinecode{try}
    \item Dopuniti sintaksnim dijagramima
\end{itemize}
\item Definicija rukovaoca i tok obrade
% 
\begin{itemize}
    \item Definicija rukovaoca liči na definiciju funkcije sa tačno jednim parametrom
    \item Završiti sa sintaksnim dijagramom i njegovim objašnjenjem
    \item Ovde samo objašnjava kako se koristi try/catch
    
    \begin{lstlisting}
try {
...
radi();                     // Funkcija mozda baca izuzetak
...
} catch(const char *pz){    // Obrada izuzetka tipa znakovnog niza
} catch(const int i){       // Obrada izuzetka celobrojnog tipa
} catch(...){               // Obrada izuzetka proizvoljnog tipa    
                            // koji nije jedan od gornjih
}
    \end{lstlisting}
\end{itemize}
\item Izazivanje izuzetaka
\begin{itemize}
    \item Prijavljivanje ili bacanje izuzetaka se vrši naredbom \inlinecode{throw izraz;} gde izraz svojim tipom određuje koji handler će biti aktivan, dok se vrednost izraza izračunava i prosleđuje handleru kao argument
    \item Izuzetak se može izazvati iz bloka ili bilo koje funkcije direktno ili indirektno pozvane iz bloka naredbe \inlinecode{try}
    \item Funkcije iz kojih se izaziva izuzetak mogu biti članice klasa, operatori, konstruktori a i destruktori
    \item Za (dinamički) ugnežđene naredbe \inlinecode{try} - ugnežđeni rukovalac može da izazove izuzetak, koji se prosleđuje rukovaocu spoljašnjeg \inlinecode{try}-a
    \item Takođe, izuzetak može da se izazove i pomoću naredbe \inlinecode{trow;} bez izraza, i takav izuzetak ima tip rukovaoca u kojem je izazvan
\end{itemize}
\item Specifikacija izuzetaka funkcije
\begin{itemize}
    \item U deklaraciji ili definiciji funkcija može da se navede spisak tipova izuzetaka koje funkcija izaziva\\
    \inlinecode{throw(niz\_identifikatora)} - iza liste argumenata
    \item Ako se stavi \inlinecode{throw()} klauzula kad funnkcija izazove izuzetak tipa koji nije nabrojan $\rightarrow$ greška
    \item Ako se izostavi \inlinecode{throw()} klauzula funkcija sme da prijavi izuzetak proizvoljnog tipa
    \item Virtuelna metoda u izvedenoj klasi ne sme da proširi listu izuzetaka iz  \inlinecode{throw()} klauzule, ali sme da ih suzi
    \item Standard C++11 ne preporučuje korišćenje \inlinecode{throw(niz\_identifikatora)}, već samo vraćanje informacije da li funkcija baca ili ne baca izuzetke
\begin{lstlisting}
void radi(...)throw(const char *, int){
if(...) throw "Izuzetak!";
if(...) throw 100;
if(...) throw Tacka(0,0);   // ERROR nije naveden tip izuzetka Tacka
}
\end{lstlisting}
\end{itemize} 
\item Modifikator i operator \inlinecode{noexcept}
\begin{itemize}
    \item Modifikator
    \begin{itemize}
        \item[\textperiodcentered]\inlinecode{throw(niz\_identifikatora)}iza liste parametara, izvršava se u toku prevođenja i vrednost \inlinecode{true} označava da funkcije ne baca izuzetke
    \end{itemize}
    \item Operator
    \begin{itemize}
        \item \inlinecode{throw(niz\_identifikatora)}, gde je rezultat izraza logičkog tipa i izraz može biti proizvoljnog tipa (čak i \inlinecode{void})
        \item Izraz se ne izračunava, samo proverava u toku izvođenja, proverava se da li bi u slučaju izvršenja izraza moglo doći do izuzetka
        \item Može da se koristi i u gorenavedenom modifikatoru
    \end{itemize}
    \begin{lstlisting}
void f() noexcept {}                    // ne baca
int g() noexcept(false){return 0;}      // moze da baca
double h() {return 0.0;}                // moze da baca
int i() throw(){return 0;}              // ne baca
void j() throw (int, double){}
                                        // moze da baca int i double
bool p=noexcept(f());                   // true
bool q=noexcept(g());                   // false
bool r=noexcept(h());                   // false
bool s=noexcept(i());                   // true
bool t=noexcept(j());                   // false
bool v=noexcept(new int);               // false        
    \end{lstlisting}
\end{itemize}
\item Prihvatanje izuzetaka - pravila
\begin{itemize}
    \item Rukovalac tipa R može da primi izuzetak tipa I ako
    \begin{enumerate}
        \item R i I su isti tip
        \item R je javna osnovna klasa za izvedenu klasu I
        \item R i I su pokazivački/refrentni tipovi i I standardno može da se konvertuje u R
    \end{enumerate}‚
    \item Prilikom navođenja rukovaoca treba se držati sledećih pravila
    \begin{enumerate}
        \item Rukovaoce tipa izvedenog iz neke osnovne klase treba stavljati ispred rukovaoca tipa te osnovne klase
        \item Univerzalni rukovalac na poslednje mesto
    \end{enumerate}
\end{itemize}
\item Prosleđivanje objekta izuzetka
\begin{itemize}
    \item Na mestu izazivanja izuzetka formira se objekat koji se prosleđuje rukovaocu 
    \item Objekat koji se prosleđuje je po pravilu kopija objekta rezultata izraza operatora \inlinecode{throw}
    \item Prevodilac može da odluči da ne napravi kopiju - tada se za objekaz uzima rezultat izraza
    \item To može biti i bezimeni privremeni objekat ili lokalni automatski objekat, ali svakako mora da ima kopirajući i/ili premeštajući konstruktor i destruktor
    \item Objekat se prosleđuje i obrađuje u najboliže, prvom odgovarajućem rukovaocu
    \item Ako se ne pronađe odgovarajući rukovalac objekat se prosleđuje prethodnom nivou \inlinecode{try}
\end{itemize}
\item Obrada izuzetka u ugnežđenim \inlinecode{try}
\begin{itemize}
    \item Ako su \inlinecode{try} naredbe ugnežđene i ako se pronađe rukovalac tekuće naredbe - on obrađuje izuzetak, i ako se ne baci dalje, nastavlja se naredbom koja se nalazi posle poslednjeg \inlinecode{catch} bloka
    \item Ako se ne pronađe odgovarajući rukovalac - izuzetak se prosleđuje rukovaocu prethodnog nivoa naredbe \inlinecode{try}, a ni jedna naredba posle \inlinecode{catch} se \textbf{neće} izvršiti
    \item U slučaju da se izuzetak baci iz \inlinecode{catch} bloka naredbom \inlinecode{throw;}, i on se prosleđuje rukovaocu prethodnog nivoa, a objekat izuzetka ostaje živ i u \inlinecode{catch} bloku tog \inlinecode{try}
\end{itemize}
\item Uništavanje lokalnih objekata
\begin{itemize}
    \item Predaja kontrole rukovaocu podrazumeva napuštanje bloak gde se dogodio izuzetak
    \item Uništavaju se svi lokalni objekti tog i svih ugnežđenih blokova
    \item Uništava se redosledom obrnutim od stvaranja
    \item Kod izuzetaka bačenih iz konstruktora uništavaju se stvoreni klasni atributi i nasleđeni podobjekti
    \item Nije dobro da rezultat izraza \inlinecode{throw} pokazuje/upućuje na lokalni objekat, jer će on biti uništen pre nego što dođe do rukovaoca
\end{itemize}
\item Funkcijska naredba \inlinecode{try}
\begin{itemize}
    \item Telo \inlinecode{try} bloka se poklapa sa telom funkcije
    \item Modifikatori metode (npr \inlinecode{const}), i \inlinecode{throw} klauzula idu ispred try
    \item U handlerima mogu da se koriste parametri funkcije a ne mogu da se koriste lokalne promenljive
    \item Ako funkcije nije \inlinecode{void}, mora da izvrši return ako ne baci izuzetak
    \begin{lstlisting}
tip fun(parametri) try { /* telo funkcije */ }
catch (parametar1) { /* telo rukovaoca 1 */ }
catch (parametar2) { /* telo rukovaoca 2 */ }
//--------------------------------------------------------------
int f(int x) throw(double) try {
int y=0;
if (...) throw 1;             // baca se i obradjuje
if (...) throw 2.0;           // baca se i propagira dalje
...
return x+y;                 // regularan rezultat funkcije
} catch (int g) {
int a=x;                    // u redu
int b=y;                    // ERROR
return -1;                  // rezultat u izuzetnoj situaciji
            
    \end{lstlisting}
\end{itemize}
\item Funkcijski \inlinecode{try} u konstruktoru
\begin{itemize}
    \item Omogućava hvatanje izuzetaka koji se bacaju iz
    \begin{enumerate}
        \item Inicijalizatora atributa primitivnog tipa
        \item Konstruktora atributa klasnog tipa
        \item Konstruktora osnovnih klasa
    \end{enumerate}
    \item Lista inicijalizatora u definiciji konstruktora se piše iza \inlinecode{try}
    \item Ako se iz rukovaoca pristupa atributima ili nasleđenom podobjektu posledice su nepredvidive jer neki još nisu inicijalizovani, a klasni koji su već bili konstruisani su uništeni prilikom bacanja izuzetka
    \begin{lstlisting}
class A {
public:
A(int x) {... if (...) throw 'x';...}
A(char x) {... if (...) throw 2;...}
}
class B {
    A a1=A(3);
    A a2;
public:
    B() try : a2('a'){                  // Izuzetak tipa int
    ... 
    if(...) throw 4.0;                  // Izuzetak tipa double
    } catch (double g) {                // Rukovalac za tip double
    A a3(a1);                           // ERROR - a1 unisten
    } catch (char g) {                  // Rukovalac za tip char
    ...
    }                                   // Nije obradjen tip int
}
    \end{lstlisting}
\end{itemize}
\item Neprihvaćeni izuzeci
\begin{itemize}
    \item Ako se za neki izuzetak ne pronađe rukovalac - izvršava se sistemska funkcija \\
    \inlinecode{void terminate();}
    \item Podrazumeva se da ova funkcija poziva funkciju \inlinecode{abort()} - ona vraća kontrolu operativnom sistemu
    \item Ovo se može promeniti pomoću funkcije \inlinecode{set\_terminate()}
    \begin{itemize}
        \item Dostavlja se pokazivač na funkciju koju \inlinecode{terminate()} poziva umesto \inlinecode{abort()}
        \item Pokazana funkcija mora biti bez argumenata i rezultata \inlinecode{void}
        \item Vrednost funkcije \inlinecode{set\_terminate()} je pokazivač na staru funkciju koja je bila pozvana iz \inlinecode{terminate()}
    \end{itemize}
\end{itemize}
\item Zamena za \inlinecode{abort()}
\begin{itemize}
    \item Tip korisničke funkcije koja zamenjuje  \inlinecode{abort()}\\
    \inlinecode{typedef void (*PF) ();}
    \item Prototip funkcije \inlinecode{set\_terminate()}\\
    \inlinecode{PF set\_terminate(PF pf);}
    \item Iz korisničke funkcije \inlinecode{(*PF)} treba pozvati \\
    \inlinecode{exit(int), terminate()} ili \inlinecode{ abort()}
    \item Pokušaj povratka sa \inlinecode{return} iz korisničke funkcije dovešće do nasilnog prekida programa sa \inlinecode{abort()} - funkcija ne sme išta da vraća
\end{itemize}
\item Neočekivani izuzeci
\begin{itemize}
    \item Ako se u nekoj funkciji izazove neočekivani izuzetak (nije na spisku izuzetaka) izvršava se funkcija \\
    \inlinecode{void unexpected();}
    \item Podrazumeva se da ova funkcija pozove funkciju \inlinecode{terminate()}
    \item Ovo ponašanje se može promeniti pomoću \inlinecode{set\_unexpected()}
    \begin{itemize}
        \item Dstavlja joj se pokazivač na funkciju koju treba da pozove umesto \inlinecode{terminate()}
        \item Pokazana funkcija mora biti bez argumenata i rezultata (\inlinecode{void})
        \item Vrednost funkcije \inlinecode{set\_unexpected()} je pokazivač na staru funkciju koja je bila pozvana iz \inlinecode{unexpected()}
    \end{itemize}
\end{itemize}
\item Zamena za \inlinecode{terminate()}
\begin{itemize}
    \item Tip korisničke funkcije koja zamenjuje  \inlinecode{terminate()}\\
    \inlinecode{typedef void (*PF) ();}
    \item Prototip funkcije \inlinecode{set\_terminate()}\\
    \inlinecode{PF set\_terminate(PF pf);}
    \item Iz korisničke funkcije \inlinecode{(*PF)} treba pozvati \\
    \inlinecode{exit(int), terminate()} ili \inlinecode{ abort()} ili baciti izuzetak sa liste dozvoljenih ili baciti \inlinecode{bad\_exception}
    \item Pokušaj povratka sa \inlinecode{return} iz korisničke funkcije dovešće do nasilnog prekida programa sa \inlinecode{abort()} - funkcija ne sme išta da vraća
\end{itemize}
\item Standardni izuzeci
\begin{itemize}
    \item Klasa \inlinecode{exception} u zaglavlju \inlinecode{<exception>} je predak svih standardnih izuzetaka
    \item Metode standardnih klasa i neki operatori prijavljuju izuzetke klasa izvedenih iz \inlinecode{exception}, a preporučuje se i da se korisnički izuzeci izvode odatle
    \item Klasa omogućava da se pojedini tipovi izuzetaka mogu obrađivati
    \begin{enumerate}
        \item Pojedinačno
        \item U srodnim grupama
        \item Svi zajedno (ali ne kao ...)
    \end{enumerate}
\end{itemize}
\item Definicija klase \inlinecode{exception}
\begin{itemize}
    \item \inlinecode{what()} vraća pokazivač na tekstualni opis izuzetka (standard ne propisuje tekst poruka)
    \item Ni jedna metoda ne sme da prijavi izuzetak, to se obezbeđuje sa \inlinecode{noexcept}
\begin{lstlisting}
class exception {
public:
    exception() noexcept;
    exception(const exception &) noexcept;
    exception& operator=(const exception &) noexcept;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};
\end{lstlisting}
\end{itemize}

\end{xitemize}
\end{document}
